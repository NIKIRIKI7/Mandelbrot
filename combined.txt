// File: app/src/main/java/view/MenuBar.java

// File: app/src/main/java/view/MenuBar.java
package view;

import model.ColorScheme;
import model.GrayscaleScheme;
import model.NonlinearRGBScheme;
import services.FileService;
import viewmodel.FractalViewModel;
import services.AnimationService; // <-- Добавить импорт


import javax.swing.*;
import javax.swing.filechooser.FileNameExtensionFilter;
import java.awt.event.ActionEvent;
import java.awt.event.KeyEvent;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.List;

/**
 * Создает и управляет главным меню приложения для исследования фракталов.
 * Предоставляет доступ к функциям загрузки/сохранения состояния, сохранения изображений,
 * отмены действий, выбора цветовой схемы и настройки итераций.
 */
public class MenuBar extends JMenuBar {

    /** ViewModel для доступа к состоянию фрактала и выполнения действий. */
    private final FractalViewModel viewModel;
    /** Сервис для операций сохранения и загрузки файлов. */
    private final FileService fileService;
    /** Панель, отображающая фрактал (необходима для получения текущего изображения при сохранении). */
    private final FractalPanel fractalPanel;
    /** Родительское окно JFrame (используется для отображения диалоговых окон). */
    private final JFrame ownerFrame;

    private final AnimationService animationService;


    /** Пункт меню "Undo", который включается/выключается в зависимости от доступности отмены. */
    private JMenuItem undoMenuItem;
    /** Список доступных цветовых схем для выбора пользователем. */
    private final List<ColorScheme> availableColorSchemes = List.of(
            new NonlinearRGBScheme(),
            new GrayscaleScheme()
            // При необходимости добавьте сюда другие экземпляры ваших схем
    );

    /**
     * Конструирует MenuBar и инициализирует все его элементы.
     *
     * @param viewModel    ViewModel приложения. Не может быть null.
     * @param fileService  Сервис для файловых операций. Не может быть null.
     * @param fractalPanel Панель отрисовки фрактала (для сохранения изображения). Не может быть null.
     * @param ownerFrame   Главное окно приложения (для диалоговых окон). Не может быть null.
     */
    public MenuBar(FractalViewModel viewModel, FileService fileService, FractalPanel fractalPanel, JFrame ownerFrame) {
        this.viewModel = viewModel;
        this.fileService = fileService;
        this.fractalPanel = fractalPanel;
        this.ownerFrame = ownerFrame;
        this.animationService = new AnimationService();

        // Создание основных меню
        createFileMenu();
        createEditMenu();
        createViewMenu();
        createAnimationMenu(); // <-- Вызвать создание нового меню

        // Добавьте другие меню (Help, etc.) по необходимости

        // Добавление слушателя к ViewModel для отслеживания изменений
        viewModel.addPropertyChangeListener(evt -> {
            // Обновление доступности пункта "Undo"
            if (FractalViewModel.PROPERTY_CAN_UNDO.equals(evt.getPropertyName())) {
                updateUndoState((Boolean) evt.getNewValue());
            }
            // Обновление выбора цветовой схемы при изменении состояния (например, после загрузки)
            else if (FractalViewModel.PROPERTY_STATE.equals(evt.getPropertyName())) {
                updateColorSchemeSelection();
            }
        });
        // Установка начального состояния доступности "Undo"
        updateUndoState(viewModel.getUndoManager().canUndo());
        // Установка начального выбора в меню цветовых схем
        updateColorSchemeSelection();
    }

    /**
     * Создает меню "File" со стандартными опциями: Load, Save As, Exit.
     */
    private void createFileMenu() {
        JMenu fileMenu = new JMenu("File");
        fileMenu.setMnemonic(KeyEvent.VK_F); // Горячая клавиша Alt+F

        // --- Пункт "Load Fractal State..." ---
        JMenuItem loadItem = new JMenuItem("Load Fractal State...");
        loadItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_O, ActionEvent.CTRL_MASK)); // Ctrl+O
        loadItem.addActionListener(e -> loadFractal());
        fileMenu.add(loadItem);

        // --- Подменю "Save As..." ---
        JMenu saveAsMenu = new JMenu("Save As...");

        // Сохранить состояние (.frac)
        JMenuItem saveFracItem = new JMenuItem("Fractal State (.frac)");
        saveFracItem.addActionListener(e -> saveFractal());
        saveAsMenu.add(saveFracItem);

        // Сохранить изображение (.png)
        JMenuItem savePngItem = new JMenuItem("Image (.png)");
        savePngItem.addActionListener(e -> saveImage("PNG"));
        saveAsMenu.add(savePngItem);

        // Сохранить изображение (.jpg)
        JMenuItem saveJpegItem = new JMenuItem("Image (.jpg)");
        saveJpegItem.addActionListener(e -> saveImage("JPEG"));
        saveAsMenu.add(saveJpegItem);

        fileMenu.add(saveAsMenu);
        fileMenu.addSeparator(); // Разделитель

        // --- Пункт "Exit" ---
        JMenuItem exitItem = new JMenuItem("Exit");
        exitItem.setMnemonic(KeyEvent.VK_X); // Горячая клавиша X (внутри меню File)
        exitItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_Q, ActionEvent.CTRL_MASK)); // Ctrl+Q для выхода
        exitItem.addActionListener(e -> {
            // Инициируем стандартное событие закрытия окна, чтобы сработал WindowListener в MainFrame
            ownerFrame.dispatchEvent(new java.awt.event.WindowEvent(ownerFrame, java.awt.event.WindowEvent.WINDOW_CLOSING));
        });
        fileMenu.add(exitItem);

        add(fileMenu); // Добавляем меню "File" в строку меню
    }

    /**
     * Создает меню "Edit" с опцией "Undo".
     */
    private void createEditMenu() {
        JMenu editMenu = new JMenu("Edit");
        editMenu.setMnemonic(KeyEvent.VK_E); // Alt+E

        // --- Пункт "Undo" ---
        undoMenuItem = new JMenuItem("Undo");
        undoMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_Z, ActionEvent.CTRL_MASK)); // Ctrl+Z
        undoMenuItem.addActionListener(e -> viewModel.undoLastAction());
        undoMenuItem.setEnabled(false); // Изначально отмена недоступна
        editMenu.add(undoMenuItem);

        add(editMenu); // Добавляем меню "Edit" в строку меню
    }

    /**
     * Создает меню "View" с опциями выбора цветовой схемы и установки максимального числа итераций.
     */
    private void createViewMenu() {
        JMenu viewMenu = new JMenu("View");
        viewMenu.setMnemonic(KeyEvent.VK_V); // Alt+V

        // --- Подменю "Color Scheme" ---
        JMenu colorSchemeMenu = new JMenu("Color Scheme");
        ButtonGroup schemeGroup = new ButtonGroup(); // Гарантирует выбор только одной опции

        // Динамическое создание пунктов меню для каждой доступной цветовой схемы
        for (ColorScheme scheme : availableColorSchemes) {
            JRadioButtonMenuItem schemeItem = new JRadioButtonMenuItem(scheme.getName());
            // Начальное выделение устанавливается в updateColorSchemeSelection()
            schemeItem.addActionListener(e -> {
                // Если пункт выбран пользователем
                if (schemeItem.isSelected()) {
                    // Устанавливаем выбранную схему через ViewModel
                    viewModel.changeColorScheme(scheme);
                }
            });
            schemeGroup.add(schemeItem); // Добавляем в группу для эксклюзивного выбора
            colorSchemeMenu.add(schemeItem);
        }
        viewMenu.add(colorSchemeMenu);

        // --- Пункт "Set Max Iterations..." ---
        JMenuItem iterationsItem = new JMenuItem("Set Max Iterations...");
        iterationsItem.addActionListener(e -> changeMaxIterations());
        viewMenu.add(iterationsItem);

        add(viewMenu); // Добавляем меню "View" в строку меню
    }

    /**
     * Обновляет состояние (включен/выключен) пункта меню "Undo".
     * Вызывается при изменении свойства {@code FractalViewModel.PROPERTY_CAN_UNDO}.
     *
     * @param canUndo true, если операция отмены доступна, иначе false.
     */
    private void updateUndoState(boolean canUndo) {
        if (undoMenuItem != null) {
            undoMenuItem.setEnabled(canUndo);
        }
    }

    // --- Обработчики действий меню ---

    /**
     * Обрабатывает действие "Load Fractal State...".
     * Открывает диалоговое окно выбора файла, загружает состояние фрактала (.frac)
     * с помощью {@link FileService} и обновляет {@link FractalViewModel}.
     */
    private void loadFractal() {
        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setDialogTitle("Load Fractal State");
        // Фильтр для отображения только .frac файлов
        fileChooser.setFileFilter(new FileNameExtensionFilter("Fractal State Files (*.frac)", "frac"));
        fileChooser.setAcceptAllFileFilterUsed(false); // Не показывать "All Files"

        int result = fileChooser.showOpenDialog(ownerFrame); // Показываем диалог
        if (result == JFileChooser.APPROVE_OPTION) { // Если пользователь выбрал файл
            File selectedFile = fileChooser.getSelectedFile();
            try {
                // Загружаем состояние через ViewModel. ViewModel уведомит панель о необходимости перерисовки.
                viewModel.loadState(fileService.loadFractalState(selectedFile));
                // Обновление выбора цветовой схемы произойдет автоматически через слушатель свойства PROPERTY_STATE.
            } catch (Exception ex) {
                showErrorDialog("Load Error", "Error loading fractal state: " + ex.getMessage());
                ex.printStackTrace(); // Логирование ошибки для отладки
            }
        }
    }

    /**
     * Обрабатывает действие "Save Fractal State (.frac)".
     * Открывает диалоговое окно сохранения файла, получает текущее состояние из {@link FractalViewModel}
     * и сохраняет его в файл .frac с помощью {@link FileService}.
     */
    private void saveFractal() {
        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setDialogTitle("Save Fractal State As");
        fileChooser.setFileFilter(new FileNameExtensionFilter("Fractal State Files (*.frac)", "frac"));
        fileChooser.setAcceptAllFileFilterUsed(false);
        // Предлагаем имя файла по умолчанию
        fileChooser.setSelectedFile(new File("mandelbrot_state.frac"));

        int result = fileChooser.showSaveDialog(ownerFrame);
        if (result == JFileChooser.APPROVE_OPTION) {
            File selectedFile = fileChooser.getSelectedFile();
            try {
                // Сохраняем текущее состояние ViewModel в выбранный файл
                fileService.saveFractalState(viewModel.getCurrentState(), selectedFile);
            } catch (IOException ex) {
                showErrorDialog("Save Error", "Error saving fractal state: " + ex.getMessage());
                ex.printStackTrace();
            }
        }
    }

    /**
     * Обрабатывает действие "Save Image (.png)" или "Save Image (.jpg)".
     * Получает текущее отрисованное изображение из {@link FractalPanel},
     * открывает диалоговое окно сохранения файла и сохраняет изображение
     * в выбранном формате (PNG или JPEG) с помощью {@link FileService}.
     * Добавляет подпись с координатами на изображение.
     *
     * @param format Строка формата ("PNG" или "JPEG", регистронезависимо).
     */
    private void saveImage(String format) {
        // Получаем текущее отрисованное изображение из панели
        BufferedImage imageToSave = fractalPanel.getCurrentImage();

        // Проверяем, доступно ли изображение для сохранения
        if (imageToSave == null) {
            JOptionPane.showMessageDialog(ownerFrame,
                    "No fractal image available to save yet. Please wait for rendering to complete.",
                    "Save Error", JOptionPane.WARNING_MESSAGE);
            return;
        }

        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setDialogTitle("Save Image As " + format.toUpperCase());
        // Определяем расширение и описание файла для фильтра
        String extension = format.toLowerCase().equals("jpeg") ? "jpg" : format.toLowerCase();
        String description = format.toUpperCase() + " Image Files (*." + extension + ")";
        fileChooser.setFileFilter(new FileNameExtensionFilter(description, extension));
        fileChooser.setAcceptAllFileFilterUsed(false);
        // Предлагаем имя файла по умолчанию
        fileChooser.setSelectedFile(new File("mandelbrot_image." + extension));

        int result = fileChooser.showSaveDialog(ownerFrame);
        if (result == JFileChooser.APPROVE_OPTION) {
            File selectedFile = fileChooser.getSelectedFile();
            try {
                // Передаем изображение, актуальное состояние ViewModel (для координат в подписи) и формат
                fileService.saveImage(imageToSave, viewModel.getCurrentState(), selectedFile, format);
            } catch (Exception ex) {
                showErrorDialog("Save Error", "Error saving image: " + ex.getMessage());
                ex.printStackTrace();
            }
        }
    }

    /**
     * Обрабатывает действие "Set Max Iterations...".
     * Показывает диалоговое окно для ввода нового значения максимального числа итераций.
     * Если введено корректное положительное число, обновляет значение через {@link FractalViewModel}.
     */
    private void changeMaxIterations() {
        // Получаем текущее значение для отображения в диалоге
        String currentIterationsStr = Integer.toString(viewModel.getCurrentState().getMaxIterations());
        // Отображаем диалог ввода
        String input = (String) JOptionPane.showInputDialog(
                ownerFrame, // Центрировать относительно главного окна
                "Enter maximum iterations:",
                "Set Max Iterations",
                JOptionPane.PLAIN_MESSAGE,
                null, // Иконка по умолчанию
                null, // Нет списка для выбора
                currentIterationsStr // Начальное значение в поле ввода
        );

        // Если пользователь ввел значение и не нажал "Cancel"
        if (input != null && !input.trim().isEmpty()) {
            try {
                int newIterations = Integer.parseInt(input.trim());
                // Проверяем, что значение положительное
                if (newIterations > 0) {
                    // Обновляем значение через ViewModel
                    viewModel.changeMaxIterations(newIterations);
                } else {
                    showErrorDialog("Invalid Input", "Iterations must be a positive integer.");
                }
            } catch (NumberFormatException ex) {
                // Обработка ошибки, если введено не число
                showErrorDialog("Invalid Input", "Invalid number format.");
            }
        }
    }

    /**
     * Обновляет выбор радио-кнопки в меню "Color Scheme"
     * в соответствии с текущей цветовой схемой, установленной в {@link FractalViewModel}.
     * Вызывается при инициализации и при изменении состояния ({@code FractalViewModel.PROPERTY_STATE}).
     */
    private void updateColorSchemeSelection() {
        // Проверка на случай, если метод вызван до полной инициализации
        if (viewModel == null || viewModel.getCurrentState() == null) return;

        ColorScheme currentScheme = viewModel.getCurrentState().getColorScheme();
        if (currentScheme == null) return; // Дополнительная защита

        try {
            // Получаем меню "View" (предполагая, что оно третье по счету, индекс 2)
            JMenu viewMenu = getMenu(2);
            if (viewMenu != null) {
                // Ищем подменю "Color Scheme" по тексту, а не по индексу (более надежно)
                JMenu colorSchemeMenu = null;
                for (int i = 0; i < viewMenu.getItemCount(); i++) {
                    JMenuItem item = viewMenu.getItem(i);
                    // Проверяем, что это меню и текст совпадает
                    if (item instanceof JMenu && "Color Scheme".equals(item.getText())) {
                        colorSchemeMenu = (JMenu) item;
                        break;
                    }
                }

                if (colorSchemeMenu != null) {
                    // Проходим по всем пунктам подменю цветовых схем
                    for (int i = 0; i < colorSchemeMenu.getItemCount(); i++) {
                        JMenuItem item = colorSchemeMenu.getItem(i);
                        // Убеждаемся, что это радио-кнопка
                        if (item instanceof JRadioButtonMenuItem) {
                            JRadioButtonMenuItem radioItem = (JRadioButtonMenuItem) item;
                            String itemName = radioItem.getText(); // Имя схемы из пункта меню

                            // Проверяем, соответствует ли имя пункта меню и класс текущей активной схеме
                            boolean shouldBeSelected = availableColorSchemes.stream()
                                    .anyMatch(scheme -> scheme.getName().equals(itemName) &&
                                            scheme.getClass().equals(currentScheme.getClass()));

                            // Устанавливаем состояние selected, только если оно отличается от текущего,
                            // чтобы избежать рекурсивного вызова ActionListener
                            if (radioItem.isSelected() != shouldBeSelected) {
                                radioItem.setSelected(shouldBeSelected);
                            }
                        }
                    }
                }
            }
        } catch (Exception e) {
            // Логгируем ошибку, но не прерываем работу приложения
            System.err.println("Error updating color scheme menu selection: " + e.getMessage());
            e.printStackTrace();
        }
    }


    /**
     * Вспомогательный метод для отображения диалогового окна с сообщением об ошибке.
     *
     * @param title   Заголовок окна ошибки.
     * @param message Текст сообщения об ошибке.
     */
    private void showErrorDialog(String title, String message) {
        JOptionPane.showMessageDialog(ownerFrame, message, title, JOptionPane.ERROR_MESSAGE);
    }

    /**
     * Создает меню "Animation" с опцией настройки анимации.
     */
    private void createAnimationMenu() {
        JMenu animationMenu = new JMenu("Animation");
        animationMenu.setMnemonic(KeyEvent.VK_A); // Alt+A

        JMenuItem setupAnimationItem = new JMenuItem("Setup Animation...");
        setupAnimationItem.addActionListener(e -> openAnimationSetupDialog());
        animationMenu.add(setupAnimationItem);

        add(animationMenu); // Добавляем меню в строку меню
    }

    /**
     * Открывает диалоговое окно настройки анимации.
     */
    private void openAnimationSetupDialog() {
        // Создаем и отображаем диалог
        AnimationSetupDialog dialog = new AnimationSetupDialog(ownerFrame, viewModel, animationService);
        dialog.display(); // Показываем диалог
    }
}

// File: app/src/main/java/view/AnimationSettingsPanel.java

// File: app/src/main/java/view/AnimationSettingsPanel.java
package view;

import javax.swing.*;
import javax.swing.border.TitledBorder;
import java.awt.*;

/**
 * Панель для настройки общих параметров генерируемой анимации,
 * таких как длительность сегмента между ключевыми кадрами и
 * частота кадров в секунду (FPS) итогового видео.
 */
public class AnimationSettingsPanel extends JPanel {

    private final JSpinner durationSpinner;
    private final JSpinner fpsSpinner;

    /**
     * Создает панель настроек анимации.
     */
    public AnimationSettingsPanel() {
        // Используем BoxLayout для вертикального расположения или GridBagLayout для большего контроля
        //setLayout(new BoxLayout(this, BoxLayout.Y_AXIS)); // Вертикальное расположение
        setLayout(new FlowLayout(FlowLayout.LEFT, 10, 5)); // Горизонтальное расположение с отступами
        setBorder(new TitledBorder("Параметры анимации"));

        // Настройки спиннеров
        // Длительность: от 0.1 до 600 сек, шаг 0.5, значение по умолчанию 5.0
        durationSpinner = new JSpinner(new SpinnerNumberModel(5.0, 0.1, 600.0, 0.5));
        JSpinner.NumberEditor durationEditor = new JSpinner.NumberEditor(durationSpinner, "0.0"); // Формат отображения
        durationSpinner.setEditor(durationEditor);
        durationSpinner.setToolTipText("Длительность перехода между двумя соседними ключевыми кадрами (в секундах)");

        // FPS: от 1 до 120, шаг 1, значение по умолчанию 30
        fpsSpinner = new JSpinner(new SpinnerNumberModel(30, 1, 120, 1));
        fpsSpinner.setToolTipText("Количество кадров в секунду в итоговом видеофайле");

        // Добавление компонентов с метками
        add(new JLabel("Сегмент (сек):"));
        add(durationSpinner);
        add(Box.createHorizontalStrut(15)); // Промежуток между настройками
        add(new JLabel("FPS:"));
        add(fpsSpinner);

        // Выравнивание компонентов, если используется BoxLayout
        // durationSpinner.setAlignmentX(Component.LEFT_ALIGNMENT);
        // fpsSpinner.setAlignmentX(Component.LEFT_ALIGNMENT);
        // ((JLabel)getComponent(0)).setAlignmentX(Component.LEFT_ALIGNMENT);
        // ((JLabel)getComponent(2)).setAlignmentX(Component.LEFT_ALIGNMENT);

    }

    /**
     * Возвращает выбранное значение длительности одного сегмента анимации
     * (перехода между двумя ключевыми кадрами).
     *
     * @return Длительность сегмента в секундах (тип double).
     */
    public double getDurationPerSegment() {
        // JSpinner возвращает Object, нужно привести к Number и взять doubleValue
        return ((Number) durationSpinner.getValue()).doubleValue();
    }

    /**
     * Возвращает выбранное значение частоты кадров в секунду (FPS)
     * для генерируемого видеофайла.
     *
     * @return Частота кадров (тип int).
     */
    public int getFps() {
        return (Integer) fpsSpinner.getValue();
    }
}

// File: app/src/main/java/view/AnimationSetupDialog.java

// File: app/src/main/java/view/AnimationSetupDialog.java
package view;

import model.ColorScheme;
import model.FractalState;
import model.Keyframe;
import model.Viewport;
import services.AnimationService;
import viewmodel.FractalViewModel;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.ExecutionException;
import java.text.ParseException;

/**
 * Диалоговое окно для настройки параметров анимации фрактала.
 * Выступает координатором для дочерних панелей:
 * {@link KeyframeListPanel}, {@link KeyframePreviewPanel},
 * {@link KeyframeParametersPanel}, {@link AnimationSettingsPanel}, {@link GenerationControlPanel}.
 */
public class AnimationSetupDialog extends JDialog {

    private final FractalViewModel mainViewModel; // Для получения начального вида
    private final AnimationService animationService;

    // Модель данных списка (общая для списка и диалога)
    private final DefaultListModel<Keyframe> keyframeListModel;

    // Дочерние панели UI
    private KeyframeListPanel keyframeListPanel;
    private KeyframePreviewPanel keyframePreviewPanel;
    private KeyframeParametersPanel keyframeParametersPanel;
    private AnimationSettingsPanel animationSettingsPanel;
    private GenerationControlPanel generationControlPanel;

    // Фоновая задача для генерации
    private SwingWorker<Void, String> animationWorker = null;

    /**
     * Создает диалог настройки анимации.
     * @param ownerFrame Родительское окно.
     * @param mainViewModel ViewModel основного окна.
     * @param animationService Сервис для генерации анимации.
     */
    public AnimationSetupDialog(JFrame ownerFrame, FractalViewModel mainViewModel, AnimationService animationService) {
        super(ownerFrame, "Редактор анимации фрактала", true);
        this.mainViewModel = mainViewModel;
        this.animationService = animationService;
        this.keyframeListModel = new DefaultListModel<>();

        createAndLayoutPanels();
        setupInteractionLogic(); // Этот метод теперь пуст, логика в обработчиках

        pack();
        setMinimumSize(new Dimension(850, 650));
        setLocationRelativeTo(ownerFrame);
        setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE); // Ручная обработка закрытия

        addWindowListener(new WindowAdapter() {
            @Override
            public void windowClosing(WindowEvent e) {
                handleClose();
            }
        });
    }

    /**
     * Создает и размещает дочерние панели UI.
     */
    private void createAndLayoutPanels() {
        // 1. Создаем панели, передавая ссылки на методы-обработчики этого диалога
        keyframeListPanel = new KeyframeListPanel(
                keyframeListModel,
                this::addCurrentViewAsKeyframe,
                this::removeSelectedKeyframe,
                this::handleListSelectionChange // Передаем метод как Consumer<Integer>
        );

        keyframePreviewPanel = new KeyframePreviewPanel(
                this::loadSelectedToPreview,
                this::updateSelectedKeyframe
        );

        keyframeParametersPanel = new KeyframeParametersPanel(
                this::applyFieldsToPreview
        );

        animationSettingsPanel = new AnimationSettingsPanel();

        generationControlPanel = new GenerationControlPanel(
                this::startOrCancelAnimationGeneration
        );

        // 2. Размещаем панели в диалоге
        JPanel rightTopPanel = new JPanel(new BorderLayout(10, 10));
        rightTopPanel.add(keyframePreviewPanel, BorderLayout.CENTER);
        rightTopPanel.add(keyframeParametersPanel, BorderLayout.EAST);

        JPanel rightPanel = new JPanel();
        rightPanel.setLayout(new BoxLayout(rightPanel, BoxLayout.Y_AXIS));
        rightPanel.add(rightTopPanel);
        rightPanel.add(Box.createVerticalStrut(10));
        rightPanel.add(animationSettingsPanel);
        rightPanel.add(Box.createVerticalGlue());

        JSplitPane splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, keyframeListPanel, rightPanel);
        splitPane.setDividerLocation(280);
        splitPane.setResizeWeight(0.3);

        setLayout(new BorderLayout(10, 10));
        add(splitPane, BorderLayout.CENTER);
        add(generationControlPanel, BorderLayout.SOUTH);

        Container contentPane = getContentPane();
        if (contentPane instanceof JPanel) {
            ((JPanel) contentPane).setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
        }
    }

    /**
     * Настраивает логику взаимодействия между панелями.
     * (В данной реализации основная логика встроена в обработчики событий).
     */
    private void setupInteractionLogic() {
        // Слушатели кнопок уже настроены при создании панелей.
        // Логика обновления UI при выборе элемента списка находится в handleListSelectionChange.
    }


    // --- Методы-обработчики событий от дочерних панелей ---

    /** Вызывается при изменении выбора в KeyframeListPanel. */
    private void handleListSelectionChange(int selectedIndex) {
        boolean selected = (selectedIndex != -1);
        keyframePreviewPanel.setControlButtonsEnabled(selected);
        keyframeParametersPanel.setFieldsEnabled(selected);
        // Кнопка "Удалить" обновляется внутри KeyframeListPanel

        if (selected) {
            Keyframe selectedKeyframe = keyframeListModel.getElementAt(selectedIndex);
            loadStateToPreviewAndFields(selectedKeyframe.getState()); // Обновляем предпросмотр и поля
            generationControlPanel.setStatus("Выбран кадр: " + selectedKeyframe.getName());
        } else {
            keyframePreviewPanel.loadState(null); // Очищаем предпросмотр
            keyframeParametersPanel.clearFields(); // Очищаем поля
            generationControlPanel.setStatus("Выберите кадр или добавьте новый.");
        }
    }

    /** Загружает состояние в предпросмотр и поля параметров. */
    private void loadStateToPreviewAndFields(FractalState state) {
        keyframePreviewPanel.loadState(state);
        keyframeParametersPanel.updateFields(state);
    }

    /** Добавляет текущий вид из главного окна как кадр. */
    private void addCurrentViewAsKeyframe(ActionEvent e) {
        FractalState currentState = mainViewModel.getCurrentState();
        if (currentState != null) {
            Keyframe newKeyframe = new Keyframe(currentState);
            keyframeListModel.addElement(newKeyframe);
            int newIndex = keyframeListModel.getSize() - 1;
            keyframeListPanel.setSelectedIndex(newIndex); // Выделит и вызовет handleListSelectionChange
            keyframeListPanel.ensureIndexIsVisible(newIndex);
            // Статус обновится в handleListSelectionChange
        } else {
            showError("Не удалось получить текущее состояние фрактала.");
        }
    }

    /** Удаляет выбранный кадр. */
    private void removeSelectedKeyframe(ActionEvent e) {
        int selectedIndex = keyframeListPanel.getSelectedIndex();
        if (selectedIndex != -1) {
            Keyframe removed = keyframeListModel.remove(selectedIndex);
            generationControlPanel.setStatus("Удален кадр: " + removed.getName());
            // handleListSelectionChange будет вызван автоматически после удаления
        } else {
            showWarning("Сначала выберите кадр для удаления.");
        }
    }

    /** Загружает выбранный кадр в предпросмотр. */
    private void loadSelectedToPreview(ActionEvent e) {
        int selectedIndex = keyframeListPanel.getSelectedIndex();
        if (selectedIndex != -1) {
            Keyframe selectedKeyframe = keyframeListModel.getElementAt(selectedIndex);
            loadStateToPreviewAndFields(selectedKeyframe.getState());
            generationControlPanel.setStatus("Состояние кадра '" + selectedKeyframe.getName() + "' загружено в предпросмотр.");
        } else {
            showWarning("Сначала выберите кадр для загрузки в предпросмотр.");
        }
    }

    /** Обновляет выбранный кадр состоянием из предпросмотра. */
    private void updateSelectedKeyframe(ActionEvent e) {
        int selectedIndex = keyframeListPanel.getSelectedIndex();
        if (selectedIndex != -1) {
            FractalState previewState = keyframePreviewPanel.getCurrentState();
            if (previewState != null) {
                String existingName = keyframeListModel.getElementAt(selectedIndex).getName();
                Keyframe updatedKeyframe = new Keyframe(previewState, existingName);
                keyframeListModel.set(selectedIndex, updatedKeyframe); // Заменяем
                keyframeParametersPanel.updateFields(previewState); // Обновляем поля согласно предпросмотру
                generationControlPanel.setStatus("Кадр '" + updatedKeyframe.getName() + "' обновлен.");
            } else {
                showError("Не удалось получить состояние из панели предпросмотра.");
            }
        } else {
            showWarning("Сначала выберите кадр для обновления.");
        }
    }

    /** Применяет значения из полей параметров к предпросмотру. */
    private void applyFieldsToPreview(ActionEvent e) {
        try {
            Object[] params = keyframeParametersPanel.getValidatedParameters();
            // params[0] - Viewport, params[1] - Integer iterations
            Viewport newViewport = (Viewport) params[0];
            int newIterations = (Integer) params[1];

            FractalState currentStateInPreview = keyframePreviewPanel.getCurrentState();
            // Если в предпросмотре ничего нет, берем дефолтные схему и функцию
            ColorScheme scheme = (currentStateInPreview != null) ? currentStateInPreview.getColorScheme() : FractalState.createDefault().getColorScheme();
            math.FractalFunction function = (currentStateInPreview != null) ? currentStateInPreview.getFractalFunction() : FractalState.createDefault().getFractalFunction();

            FractalState newState = new FractalState(newViewport, newIterations, scheme, function);
            keyframePreviewPanel.loadState(newState); // Загружаем в предпросмотр
            generationControlPanel.setStatus("Параметры из полей применены к предпросмотру.");

        } catch (ParseException | IllegalArgumentException | NullPointerException ex) {
            showError("Ошибка ввода параметров: " + ex.getMessage());
        }
    }

    /** Запускает или отменяет генерацию анимации. */
    private void startOrCancelAnimationGeneration(ActionEvent e) {
        if (animationWorker != null && !animationWorker.isDone()) {
            animationWorker.cancel(true);
            generationControlPanel.setStatus("Запрос на отмену генерации...");
            generationControlPanel.setGenerateButtonEnabled(false); // Блокируем на время отмены
            return;
        }

        if (keyframeListModel.getSize() < 2) {
            showError("Нужно как минимум два ключевых кадра для анимации.");
            return;
        }

        final List<Keyframe> keyframes = new ArrayList<>(keyframeListModel.getSize());
        for (int i = 0; i < keyframeListModel.getSize(); i++) keyframes.add(keyframeListModel.getElementAt(i));
        final double durationPerSegment = animationSettingsPanel.getDurationPerSegment();
        final int fps = animationSettingsPanel.getFps();

        JFileChooser fileChooser = new JFileChooser();
        // ... (настройка fileChooser, проверка перезаписи - без изменений) ...
        fileChooser.setDialogTitle("Сохранить видео анимации как...");
        fileChooser.setFileFilter(new javax.swing.filechooser.FileNameExtensionFilter("MP4 Video File (*.mp4)", "mp4"));
        fileChooser.setSelectedFile(new File("fractal_animation.mp4"));

        int userSelection = fileChooser.showSaveDialog(this);
        if (userSelection != JFileChooser.APPROVE_OPTION) {
            generationControlPanel.setStatus("Сохранение отменено.");
            return;
        }
        final File outputFile = ensureMp4Extension(fileChooser.getSelectedFile());

        if (outputFile.exists()) {
            int overwriteChoice = JOptionPane.showConfirmDialog(this,
                    "Файл '" + outputFile.getName() + "' уже существует.\nПерезаписать его?",
                    "Подтверждение перезаписи", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);
            if (overwriteChoice != JOptionPane.YES_OPTION) {
                generationControlPanel.setStatus("Сохранение отменено.");
                return;
            }
        }


        generationControlPanel.setProgress(0);
        generationControlPanel.setProgressVisible(true);
        generationControlPanel.setStatus("Подготовка к генерации...");
        generationControlPanel.setGenerateButtonText("Отмена");
        generationControlPanel.setGenerateButtonEnabled(true); // Кнопка "Отмена" активна

        // Блокируем UI на время генерации
        setUIEnabled(false);

        animationWorker = new SwingWorker<Void, String>() {
            private long startTime;
            @Override protected Void doInBackground() throws Exception { /* ... код без изменений ... */
                startTime = System.currentTimeMillis();
                animationService.createAndSaveAnimation(
                        keyframes, fps, durationPerSegment, outputFile,
                        progress -> publishProgress(progress), // Используем отдельный метод
                        message -> publish(message)
                );
                return null;
            }
            @Override protected void process(List<String> chunks) { /* ... код без изменений ... */
                if (!isCancelled() && !chunks.isEmpty()) {
                    generationControlPanel.setStatus(chunks.get(chunks.size() - 1));
                }
            }
            @Override protected void done() { /* ... код обработки done() с небольшими изменениями ... */
                try {
                    if (!isCancelled()) {
                        get();
                        long endTime = System.currentTimeMillis();
                        generationControlPanel.setStatus(String.format("Генерация завершена успешно! (%.1f сек)", (endTime - startTime) / 1000.0));
                        showInfo("Анимация успешно сохранена в файл:\n" + outputFile.getAbsolutePath(), "Генерация завершена");
                        generationControlPanel.setProgress(100);
                    } else {
                        generationControlPanel.setStatus("Генерация отменена пользователем.");
                        generationControlPanel.setProgress(0);
                        deleteOutputFileIfExists(outputFile);
                    }
                } catch (InterruptedException e) {
                    generationControlPanel.setStatus("Генерация прервана.");
                    generationControlPanel.setProgress(0);
                    deleteOutputFileIfExists(outputFile);
                    Thread.currentThread().interrupt();
                } catch (ExecutionException e) {
                    Throwable cause = Objects.requireNonNullElse(e.getCause(), e);
                    generationControlPanel.setStatus("Ошибка генерации: " + cause.getMessage());
                    generationControlPanel.setProgress(0);
                    showError("Произошла ошибка во время генерации анимации:\n" + cause.getMessage());
                    cause.printStackTrace();
                    deleteOutputFileIfExists(outputFile);
                } catch (java.util.concurrent.CancellationException e) {
                    generationControlPanel.setStatus("Генерация отменена.");
                    generationControlPanel.setProgress(0);
                    deleteOutputFileIfExists(outputFile);
                } finally {
                    generationControlPanel.setGenerateButtonText("Генерировать видео...");
                    generationControlPanel.setGenerateButtonEnabled(true); // Всегда разблокируем
                    if (!generationControlPanel.getStatus().contains("успешно")) {
                        generationControlPanel.setProgressVisible(false);
                    }
                    setUIEnabled(true); // Разблокируем UI
                    animationWorker = null;
                }
            }
            // Метод для обновления прогресса в EDT
            private void publishProgress(double progress) {
                SwingUtilities.invokeLater(() -> {
                    if (!isCancelled()) {
                        generationControlPanel.setProgress((int) (progress * 100));
                    }
                });
            }
        };
        animationWorker.execute();
    }

    /** Блокирует/разблокирует основные элементы управления UI во время генерации. */
    private void setUIEnabled(boolean enabled) {
        keyframeListPanel.setEnabled(enabled); // Блокируем всю панель списка
        keyframePreviewPanel.setEnabled(enabled); // Блокируем панель предпросмотра
        keyframeParametersPanel.setEnabled(enabled); // Блокируем панель параметров
        animationSettingsPanel.setEnabled(enabled); // Блокируем панель настроек
        // Кнопка генерации управляется отдельно
    }


    /** Вспомогательный метод для удаления файла. */
    private void deleteOutputFileIfExists(File file) {
        if (file != null && file.exists()) {
            if (!file.delete()) { System.err.println("Не удалось удалить файл: " + file.getAbsolutePath()); }
            else { System.out.println("Файл удален: " + file.getAbsolutePath()); }
        }
    }

    /** Гарантирует расширение .mp4. */
    private File ensureMp4Extension(File file) {
        // ... (код без изменений) ...
        String path = file.getAbsolutePath();
        String lowerPath = path.toLowerCase();
        if (!lowerPath.endsWith(".mp4")) {
            int dotIndex = path.lastIndexOf('.');
            int slashIndex = path.lastIndexOf(File.separatorChar);
            if (dotIndex > slashIndex) path = path.substring(0, dotIndex);
            return new File(path + ".mp4");
        }
        return file;
    }

    /** Показывает диалоговое окно. */
    public void display() {
        // Сброс UI к начальному состоянию
        generationControlPanel.setStatus("Выберите кадр или добавьте новый.");
        generationControlPanel.setProgressVisible(false);
        generationControlPanel.setProgress(0);
        generationControlPanel.setGenerateButtonText("Генерировать видео...");
        generationControlPanel.setGenerateButtonEnabled(true);
        keyframePreviewPanel.setControlButtonsEnabled(false);
        keyframeParametersPanel.setFieldsEnabled(false);
        keyframeParametersPanel.clearFields();
        keyframeListModel.clear(); // Очищаем список кадров при каждом открытии
        keyframePreviewPanel.loadState(null); // Очищаем предпросмотр
        setUIEnabled(true); // Убедимся, что UI разблокирован
        setVisible(true);
    }

    /** Обрабатывает закрытие окна диалога. */
    private void handleClose() {
        if (animationWorker != null && !animationWorker.isDone()) {
            int choice = JOptionPane.showConfirmDialog(this,
                    "Генерация анимации еще не завершена. Прервать и закрыть окно?",
                    "Подтверждение закрытия", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);
            if (choice == JOptionPane.NO_OPTION) return;
            animationWorker.cancel(true);
        }
        keyframePreviewPanel.shutdownRenderer(); // Останавливаем рендерер предпросмотра
        dispose(); // Закрываем диалог
    }

    // Вспомогательные методы для сообщений
    private void showError(String message) { JOptionPane.showMessageDialog(this, message, "Ошибка", JOptionPane.ERROR_MESSAGE); }
    private void showWarning(String message) { JOptionPane.showMessageDialog(this, message, "Внимание", JOptionPane.WARNING_MESSAGE); }
    private void showInfo(String message, String title) { JOptionPane.showMessageDialog(this, message, title, JOptionPane.INFORMATION_MESSAGE); }
}

// File: app/src/main/java/view/FractalPanel.java

// File: app/src/main/java/view/FractalPanel.java
package view;

import listeners.MousePanListener;
import listeners.MouseZoomListener;
import model.ColorScheme; // Импорт нужен для передачи в JuliaSetWindow
import model.FractalState;
import render.FractalRenderer;
import utils.ComplexNumber; // Импорт нужен для координат Жюлиа
import utils.CoordinateConverter; // Импорт нужен для координат Жюлиа
import viewmodel.FractalViewModel;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;

/**
 * Компонент JPanel, отвечающий за отображение отрисованного изображения фрактала.
 * Слушает обновления от {@link FractalViewModel}, обрабатывает взаимодействия с мышью
 * (масштабирование выделением, панорамирование, вызов окна множества Жюлиа по двойному клику)
 * и управляет процессом рендеринга через {@link FractalRenderer}.
 * Реализует {@link PropertyChangeListener} для реакции на изменения состояния модели.
 */
public class FractalPanel extends JPanel implements PropertyChangeListener {

    /** ViewModel приложения, управляющая состоянием фрактала. */
    private final FractalViewModel viewModel;
    /**
     * Изображение фрактала. Используется {@code volatile} для обеспечения видимости
     * между потоком рендеринга и потоком диспетчеризации событий (EDT).
     */
    private volatile BufferedImage fractalImage;
    /** Рендерер, выполняющий вычисления и отрисовку фрактала в отдельном потоке. */
    private final FractalRenderer renderer;
    /** Слушатель для обработки масштабирования (зума) выделением области левой кнопкой мыши. */
    private final MouseZoomListener zoomListener;
    /** Слушатель для обработки панорамирования (перетаскивания) правой кнопкой мыши. */
    private final MousePanListener panListener;
    /**
     * Флаг, указывающий, идет ли процесс рендеринга в данный момент.
     * Используется {@code volatile} для потокобезопасного доступа из EDT и потока рендеринга.
     */
    private volatile boolean isRendering = false;
    /**
     * Статусное сообщение, отображаемое на панели (например, "Rendering...", "Ready.", координаты).
     * Используется {@code volatile} для потокобезопасного доступа.
     */
    private volatile String statusMessage = "Initializing...";

    /**
     * Конструирует FractalPanel.
     * Инициализирует слушателей мыши для масштабирования, панорамирования и открытия окна множества Жюлиа.
     * Добавляет слушателей для событий изменения размера/видимости компонента и изменений состояния ViewModel
     * для запуска рендеринга.
     *
     * @param viewModel ViewModel приложения. Не может быть null.
     * @param renderer  Рендерер фрактала. Не может быть null.
     */
    public FractalPanel(FractalViewModel viewModel, FractalRenderer renderer) {
        this.viewModel = viewModel;
        this.renderer = renderer;
        this.fractalImage = null; // Изображение изначально отсутствует

        // Подписываемся на изменения в ViewModel
        this.viewModel.addPropertyChangeListener(this);
        setBackground(Color.BLACK); // Цвет фона по умолчанию
        setOpaque(true); // Компонент непрозрачный

        // Инициализация слушателей мыши
        zoomListener = new MouseZoomListener(viewModel, this);
        panListener = new MousePanListener(viewModel, this);

        // Добавление слушателей событий мыши к панели
        addMouseListener(zoomListener);       // Нажатие/отпускание для зума
        addMouseMotionListener(zoomListener); // Перетаскивание для зума
        addMouseListener(panListener);       // Нажатие/отпускание для панорамирования
        addMouseMotionListener(panListener); // Перетаскивание для панорамирования

        // Слушатель для отслеживания изменения размера и момента первого отображения панели
        addComponentListener(new ComponentAdapter() {
            /**
             * Вызывается при изменении размера панели. Запускает рендеринг,
             * если панель видима и имеет корректные размеры.
             * @param e Событие изменения компонента.
             */
            @Override
            public void componentResized(ComponentEvent e) {
                 if (isShowing() && getWidth() > 0 && getHeight() > 0) {
                    System.out.println("Panel resized ("+ getWidth() + "x" + getHeight() +"). Triggering render.");
                    triggerRender(); // Запускаем перерисовку при изменении размера
                }
            }

            /**
             * Вызывается, когда панель становится видимой. Запускает рендеринг,
             * если панель имеет корректные размеры. Важно для инициализации
             * после того, как компоновщик определил размеры.
             * @param e Событие изменения компонента.
             */
            @Override
            public void componentShown(ComponentEvent e) {
                 if (getWidth() > 0 && getHeight() > 0) {
                   System.out.println("Panel shown ("+ getWidth() + "x" + getHeight() +"). Triggering render.");
                   triggerRender(); // Запускаем перерисовку при первом отображении
               }
            }
       });

       // Слушатель для обработки двойного клика левой кнопкой мыши для открытия окна Жюлиа
       addMouseListener(new MouseAdapter() {
            /**
             * Вызывается при клике мыши. Проверяет двойной клик левой кнопкой
             * и вызывает {@link #openJuliaSetWindow(Point)} для открытия
             * соответствующего окна множества Жюлиа.
             * @param e Событие мыши.
             */
            @Override
            public void mouseClicked(MouseEvent e) {
                // Проверяем двойной клик левой кнопкой
                if (e.getClickCount() == 2 && SwingUtilities.isLeftMouseButton(e)) {
                    System.out.println("Double-click detected at: " + e.getPoint());
                    openJuliaSetWindow(e.getPoint()); // Открываем окно Жюлиа
                }
            }
        });
    }

    /**
     * Открывает окно для отображения множества Жюлиа, соответствующего комплексной
     * координате 'c', которая соответствует точке {@code screenPoint} на панели.
     * Получает текущую цветовую схему и количество итераций из {@link FractalViewModel}
     * для инициализации вида множества Жюлиа.
     *
     * @param screenPoint Точка на панели (в экранных координатах), где произошел двойной клик.
     */
    private void openJuliaSetWindow(Point screenPoint) {
        int w = getWidth();
        int h = getHeight();
        FractalState currentState = viewModel.getCurrentState(); // Получаем текущее состояние

        // Проверка валидности размеров панели и состояния
        if (w <= 0 || h <= 0 || currentState == null) {
            System.err.println("Cannot open Julia Set: Panel size or state invalid.");
            JOptionPane.showMessageDialog(this,
                "Cannot open Julia Set window.\nPanel size or fractal state is invalid.",
                "Error", JOptionPane.ERROR_MESSAGE);
            return;
        }

        // Преобразуем экранные координаты клика в комплексное число 'c'
        ComplexNumber c = CoordinateConverter.screenToComplex(
            screenPoint.x, screenPoint.y, w, h, currentState.getViewport()
        );

        // Проверка успешности конвертации
        if (c == null) {
            System.err.println("Cannot open Julia Set: Failed to convert screen coordinates.");
             JOptionPane.showMessageDialog(this,
                "Cannot open Julia Set window.\nFailed to determine complex coordinates for the clicked point.",
                "Error", JOptionPane.ERROR_MESSAGE);
            return;
        }

        // Получаем текущие настройки для передачи в окно Жюлиа
        ColorScheme currentScheme = currentState.getColorScheme();
        int currentIterations = currentState.getMaxIterations();

        // Находим родительское окно JFrame для позиционирования окна Жюлиа
        JFrame owner = (JFrame) SwingUtilities.getWindowAncestor(this);
        if (owner == null) {
             System.err.println("Cannot determine owner frame for Julia Set window. It will be centered on screen.");
             // Если родительское окно не найдено, окно Жюлиа будет центрировано на экране (setLocationRelativeTo(null))
             owner = null;
        }

        // Создаем и отображаем окно Жюлиа в потоке диспетчеризации событий (EDT)
        // Используем final переменную для лямбда-выражения
        final JFrame finalOwner = owner;
        SwingUtilities.invokeLater(() -> {
            JuliaSetWindow juliaWindow = new JuliaSetWindow(finalOwner, c, currentScheme, currentIterations);
            juliaWindow.display(); // Показываем окно
        });
    }


    /**
     * Инициирует асинхронный процесс рендеринга фрактала.
     * Использует текущее состояние {@link FractalViewModel} и текущие размеры панели.
     * Отменяет любой предыдущий незавершенный процесс рендеринга перед запуском нового.
     * Обновляет статусное сообщение и запрашивает перерисовку панели для отображения индикатора загрузки.
     */
    public void triggerRender() {
        int width = getWidth();
        int height = getHeight();

        // Пропускаем рендеринг, если панель не готова или имеет некорректные размеры
        if (!isShowing() || width <= 0 || height <= 0 || renderer == null) {
            System.out.println("Skipping render: Size " + width + "x" + height + ", Showing: " + isShowing() + ", Renderer valid: " + (renderer!=null));
            statusMessage = (width <= 0 || height <= 0) ? "Panel size invalid." : "Panel not ready.";
            isRendering = false;
            repaint(); // Перерисовываем, чтобы показать статусное сообщение
            return;
        }

        System.out.println("Triggering render for size: " + width + "x" + height);
        isRendering = true; // Устанавливаем флаг рендеринга
        statusMessage = "Rendering..."; // Обновляем статус
        repaint(); // Перерисовываем для отображения "Rendering..." и индикатора загрузки

        FractalState currentState = viewModel.getCurrentState();
        // Проверка, что состояние доступно
        if (currentState == null) {
            System.err.println("Cannot render: Current state is null.");
            statusMessage = "Error: State is null.";
            isRendering = false;
            repaint();
            return;
        }

        // Вызываем асинхронный метод рендерера
        renderer.render(currentState, width, height,
                // Callback, вызываемый при успешном завершении рендеринга (в EDT)
                newImage -> {
                    isRendering = false; // Сбрасываем флаг рендеринга
                    if (newImage != null) {
                        this.fractalImage = newImage; // Обновляем изображение фрактала
                        // Обновляем статусное сообщение с деталями текущего вида
                        FractalState completedState = viewModel.getCurrentState(); // Получаем состояние на момент завершения
                        statusMessage = String.format("Ready. Viewport: X=[%.4g, %.4g], Y=[%.4g, %.4g], Iter: %d",
                                completedState.getViewport().getMinX(), completedState.getViewport().getMaxX(),
                                completedState.getViewport().getMinY(), completedState.getViewport().getMaxY(),
                                completedState.getMaxIterations());
                    } else {
                        // Обработка ошибки рендеринга
                        statusMessage = "Error during rendering.";
                        this.fractalImage = null; // Убираем старое изображение
                    }
                    repaint(); // Перерисовываем панель с новым изображением или статусом ошибки
                },
                // Callback, вызываемый при отмене рендеринга (в EDT)
                () -> {
                    isRendering = false; // Сбрасываем флаг рендеринга
                    FractalState cancelledState = viewModel.getCurrentState(); // Получаем состояние на момент отмены
                    // Обновляем статус, указывая на отмену и параметры на тот момент
                     if (cancelledState != null) { // Добавим проверку, вдруг состояние успело стать null
                        statusMessage = String.format("Cancelled. Viewport: X=[%.4g, %.4g], Y=[%.4g, %.4g], Iter: %d",
                                cancelledState.getViewport().getMinX(), cancelledState.getViewport().getMaxX(),
                                cancelledState.getViewport().getMinY(), cancelledState.getViewport().getMaxY(),
                                cancelledState.getMaxIterations());
                     } else {
                         statusMessage = "Cancelled. (State unavailable)";
                     }
                    // Не очищаем изображение, оставляем то, что успело отрисоваться или было до этого
                    repaint(); // Перерисовываем для обновления статусного сообщения
                }
        );
    }

    /**
     * Отрисовывает содержимое компонента.
     * Вызывается системой Swing при необходимости перерисовки панели (например, после вызова repaint()).
     * Рисует фон, затем актуальное изображение фрактала (если доступно) или статусное сообщение.
     * Если идет рендеринг, поверх рисуется индикатор загрузки.
     * Также рисует прямоугольник выделения для зума, если пользователь его рисует.
     *
     * @param g Графический контекст для отрисовки.
     */
    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g); // Отрисовка фона панели

        // Атомарно получаем текущие значения volatile переменных
        BufferedImage currentImage = this.fractalImage;
        boolean renderingNow = this.isRendering;
        String currentStatus = this.statusMessage;

        // Рисуем изображение фрактала, если оно есть
        if (currentImage != null) {
            g.drawImage(currentImage, 0, 0, this);
        } else {
            // Если изображения нет, рисуем фон и статусное сообщение по центру
            g.setColor(Color.DARK_GRAY); // Цвет фона для текста
            g.fillRect(0, 0, getWidth(), getHeight()); // Заливаем фон, чтобы скрыть возможные артефакты
            g.setColor(Color.WHITE); // Цвет текста
            g.setFont(new Font("SansSerif", Font.PLAIN, 16));
            FontMetrics fm = g.getFontMetrics();
            String message = currentStatus != null ? currentStatus : "Status unavailable";
            int stringWidth = fm.stringWidth(message);
            int stringAscent = fm.getAscent();
            // Центрируем текст по горизонтали и вертикали
            int x = (getWidth() - stringWidth) / 2;
            int y = (getHeight() - stringAscent) / 2 + fm.getAscent(); // Более точное центрирование по вертикали
            g.drawString(message, x, y);
        }

        // Рисуем индикатор загрузки поверх всего, если идет рендеринг
        if (renderingNow) {
            drawLoadingIndicator(g);
        }

        // Рисуем прямоугольник выделения для зума (если пользователь тянет мышь)
        // Метод drawSelectionRectangle сам проверит, нужно ли рисовать
        zoomListener.drawSelectionRectangle(g);
    }

    /**
     * Отрисовывает индикатор загрузки: полупрозрачный прямоугольник с текстом "Rendering...".
     *
     * @param g Графический контекст для отрисовки.
     */
    private void drawLoadingIndicator(Graphics g) {
        // Сохраняем текущие настройки Graphics
        Graphics2D g2d = (Graphics2D) g.create();
        try {
            // Полупрозрачный черный фон для индикатора
            g2d.setColor(new Color(0, 0, 0, 150)); // Черный с альфа-каналом
            int indicatorHeight = 40;
            int indicatorY = getHeight() / 2 - indicatorHeight / 2; // Центрируем по вертикали
            g2d.fillRect(0, indicatorY, getWidth(), indicatorHeight);

            // Текст "Rendering..." белым цветом
            g2d.setColor(Color.WHITE);
            g2d.setFont(new Font("SansSerif", Font.BOLD, 18));
            FontMetrics fm = g2d.getFontMetrics();
            String loadingText = "Rendering...";
            int stringWidth = fm.stringWidth(loadingText);
            // Центрируем текст внутри прямоугольника индикатора
            int textX = (getWidth() - stringWidth) / 2;
            int textY = indicatorY + (indicatorHeight - fm.getHeight()) / 2 + fm.getAscent();
            g2d.drawString(loadingText, textX, textY);
        } finally {
            g2d.dispose(); // Восстанавливаем исходные настройки Graphics
        }
    }

    /**
     * Обрабатывает события изменения свойств, поступающие от {@link FractalViewModel}.
     * Реагирует на изменение свойства {@code FractalViewModel.PROPERTY_STATE},
     * запуская перерисовку фрактала {@link #triggerRender()}.
     *
     * @param evt Событие изменения свойства {@link PropertyChangeEvent}.
     */
    @Override
    public void propertyChange(PropertyChangeEvent evt) {
        // Проверяем, изменилось ли свойство состояния фрактала
        if (FractalViewModel.PROPERTY_STATE.equals(evt.getPropertyName())) {
            System.out.println("FractalPanel received state update. Triggering render.");
            // Запускаем рендеринг. Если мы уже в EDT, вызываем напрямую,
            // иначе - через invokeLater для безопасности Swing.
             if (SwingUtilities.isEventDispatchThread()) {
                 triggerRender();
             } else {
                 SwingUtilities.invokeLater(this::triggerRender);
             }
        }
    }

    /**
     * Возвращает предпочтительный размер для этой панели.
     * Используется менеджерами компоновки Swing.
     *
     * @return Рекомендуемый размер {@link Dimension} (800x600).
     */
    @Override
    public Dimension getPreferredSize() {
        // Задаем стандартный начальный размер
        return new Dimension(800, 600);
    }

    /**
     * Возвращает текущее отображаемое (или только что отрисованное) изображение фрактала.
     * Может быть использовано, например, для сохранения изображения в файл.
     * Выполняет volatile чтение поля {@code fractalImage}.
     *
     * @return Текущий {@link BufferedImage}, или {@code null}, если изображение еще не
     *         отрисовано или произошла ошибка рендеринга.
     */
    public BufferedImage getCurrentImage() {
        // Возвращаем volatile ссылку на текущее изображение
        return this.fractalImage;
    }
}

// File: app/src/main/java/view/KeyframeListPanel.java

// File: app/src/main/java/view/KeyframeListPanel.java
package view;

import model.Keyframe;
import javax.swing.*;
import javax.swing.border.TitledBorder;
import java.awt.*;
import java.awt.event.ActionListener;
import java.util.function.Consumer;

/**
 * Панель для отображения списка ключевых кадров анимации и кнопок управления этим списком.
 * Позволяет добавлять, удалять и выбирать ключевые кадры. Уведомляет внешний
 * компонент об изменении выбора в списке.
 */
public class KeyframeListPanel extends JPanel {

    private final DefaultListModel<Keyframe> keyframeListModel;
    private final JList<Keyframe> keyframeList;
    private final JButton addButton;
    private final JButton removeButton;
    // TODO: Добавить кнопки Up/Down для изменения порядка кадров

    /**
     * Создает панель списка ключевых кадров.
     *
     * @param listModel Модель данных {@link DefaultListModel} для списка {@link Keyframe}.
     * @param addAction Слушатель {@link ActionListener} для кнопки "Добавить".
     * @param removeAction Слушатель {@link ActionListener} для кнопки "Удалить".
     * @param selectionConsumer Потребитель {@link Consumer}, вызываемый при изменении выбора
     *                          в списке. Передает выбранный индекс (или -1, если выбор снят).
     */
    public KeyframeListPanel(DefaultListModel<Keyframe> listModel,
                             ActionListener addAction,
                             ActionListener removeAction,
                             Consumer<Integer> selectionConsumer) {
        this.keyframeListModel = listModel;

        setLayout(new BorderLayout(5, 5));
        setBorder(new TitledBorder("Ключевые кадры"));

        // Список
        keyframeList = new JList<>(keyframeListModel);
        keyframeList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        keyframeList.setBorder(BorderFactory.createEtchedBorder());
        // Используем cell renderer для отображения имени кадра (хотя toString() тоже работает)
        keyframeList.setCellRenderer(new DefaultListCellRenderer() {
            @Override
            public Component getListCellRendererComponent(JList<?> list, Object value, int index, boolean isSelected, boolean cellHasFocus) {
                JLabel label = (JLabel) super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);
                if (value instanceof Keyframe) {
                    label.setText(((Keyframe) value).getName());
                    label.setToolTipText(((Keyframe) value).getState().toString()); // Подсказка с полным состоянием
                }
                return label;
            }
        });
        keyframeList.addListSelectionListener(e -> {
            if (!e.getValueIsAdjusting()) { // Реагируем на окончание изменения выбора
                int selectedIndex = keyframeList.getSelectedIndex();
                updateRemoveButtonState(); // Обновляем активность кнопки "Удалить"
                if (selectionConsumer != null) {
                    selectionConsumer.accept(selectedIndex); // Уведомляем внешний компонент
                }
            }
        });

        // Кнопки
        addButton = new JButton("Добавить тек. вид");
        addButton.setToolTipText("Добавляет текущее состояние фрактала из главного окна как ключевой кадр");
        if (addAction != null) {
            addButton.addActionListener(addAction);
        }

        removeButton = new JButton("Удалить кадр");
        removeButton.setToolTipText("Удаляет выделенный ключевой кадр из списка");
        removeButton.setEnabled(false); // Изначально неактивна, пока ничего не выбрано
        if (removeAction != null) {
            removeButton.addActionListener(removeAction);
        }

        JPanel listButtonsPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        listButtonsPanel.add(addButton);
        listButtonsPanel.add(removeButton);
        // TODO: Добавить кнопки Up/Down на эту панель

        add(new JScrollPane(keyframeList), BorderLayout.CENTER);
        add(listButtonsPanel, BorderLayout.SOUTH);
    }

    /**
     * Возвращает выбранный индекс в списке ключевых кадров.
     *
     * @return Выбранный индекс или -1, если ни один элемент не выбран.
     */
    public int getSelectedIndex() {
        return keyframeList.getSelectedIndex();
    }

    /**
     * Программно устанавливает выбранный индекс в списке.
     *
     * @param index Индекс элемента для выбора.
     */
    public void setSelectedIndex(int index) {
        if (index >= 0 && index < keyframeListModel.getSize()) {
            keyframeList.setSelectedIndex(index);
        } else {
            keyframeList.clearSelection();
        }
    }

    /**
     * Гарантирует, что элемент с указанным индексом будет видим (прокручивает список при необходимости).
     *
     * @param index Индекс элемента, который должен стать видимым.
     */
    public void ensureIndexIsVisible(int index) {
        if (index >= 0 && index < keyframeListModel.getSize()) {
            keyframeList.ensureIndexIsVisible(index);
        }
    }

    /**
     * Обновляет состояние активности кнопки "Удалить" в зависимости от наличия выбора в списке.
     */
    public void updateRemoveButtonState() {
        removeButton.setEnabled(keyframeList.getSelectedIndex() != -1);
    }
}

// File: app/src/main/java/view/KeyframeParametersPanel.java

// File: app/src/main/java/view/KeyframeParametersPanel.java
package view;

import model.FractalState;
import model.Viewport;

import javax.swing.*;
import javax.swing.border.TitledBorder;
import java.awt.*;
import java.awt.event.ActionListener;
import java.text.NumberFormat;
import java.text.ParseException;
import java.util.Objects;

/**
 * Панель для отображения и ручного редактирования числовых параметров
 * (координаты Viewport, количество итераций) выбранного ключевого кадра.
 */
public class KeyframeParametersPanel extends JPanel {

    private final JFormattedTextField minXField, maxXField, minYField, maxYField, iterationsField;
    private final JButton applyFieldsButton;

    /**
     * Создает панель редактирования параметров.
     *
     * @param applyAction Слушатель {@link ActionListener} для кнопки "Применить к предпросмотру".
     *                    Вызывается, когда пользователь хочет применить значения из полей
     *                    к панели предпросмотра.
     */
    public KeyframeParametersPanel(ActionListener applyAction) {
        setLayout(new GridBagLayout());
        setBorder(new TitledBorder("Параметры кадра"));

        // Настройка форматов для полей ввода
        NumberFormat doubleFormat = NumberFormat.getNumberInstance();
        doubleFormat.setGroupingUsed(false); // Без разделителей тысяч
        doubleFormat.setMaximumFractionDigits(17); // Максимальная точность для double
        doubleFormat.setMinimumFractionDigits(1); // По крайней мере одна цифра после запятой

        NumberFormat intFormat = NumberFormat.getIntegerInstance();
        intFormat.setGroupingUsed(false);

        // Создание полей
        minXField = new JFormattedTextField(doubleFormat);
        maxXField = new JFormattedTextField(doubleFormat);
        minYField = new JFormattedTextField(doubleFormat);
        maxYField = new JFormattedTextField(doubleFormat);
        iterationsField = new JFormattedTextField(intFormat);
        iterationsField.setValue(100); // Значение по умолчанию

        // Установка предпочтительной ширины полей
        Dimension fieldDim = new Dimension(140, iterationsField.getPreferredSize().height);
        minXField.setPreferredSize(fieldDim);
        maxXField.setPreferredSize(fieldDim);
        minYField.setPreferredSize(fieldDim);
        maxYField.setPreferredSize(fieldDim);
        iterationsField.setPreferredSize(fieldDim);

        // Размещение компонентов с GridBagLayout
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.insets = new Insets(3, 5, 3, 5); // Немного увеличены отступы
        gbc.anchor = GridBagConstraints.WEST;

        // Метки и поля
        gbc.gridx = 0; gbc.gridy = 0; add(new JLabel("Min X:"), gbc);
        gbc.gridx = 1; gbc.gridy = 0; add(minXField, gbc);
        gbc.gridx = 0; gbc.gridy = 1; add(new JLabel("Max X:"), gbc);
        gbc.gridx = 1; gbc.gridy = 1; add(maxXField, gbc);
        gbc.gridx = 0; gbc.gridy = 2; add(new JLabel("Min Y:"), gbc);
        gbc.gridx = 1; gbc.gridy = 2; add(minYField, gbc);
        gbc.gridx = 0; gbc.gridy = 3; add(new JLabel("Max Y:"), gbc);
        gbc.gridx = 1; gbc.gridy = 3; add(maxYField, gbc);
        gbc.gridx = 0; gbc.gridy = 4; add(new JLabel("Итерации:"), gbc);
        gbc.gridx = 1; gbc.gridy = 4; add(iterationsField, gbc);

        // Кнопка "Применить"
        applyFieldsButton = new JButton("Применить к предпросмотру");
        applyFieldsButton.setToolTipText("Применяет значения из полей к панели предпросмотра");
        if (applyAction != null) {
            applyFieldsButton.addActionListener(applyAction);
        }
        gbc.gridx = 0; gbc.gridy = 5; gbc.gridwidth = 2; // Растягиваем на 2 колонки
        gbc.anchor = GridBagConstraints.CENTER; // Центрируем кнопку
        gbc.insets = new Insets(10, 5, 5, 5); // Увеличиваем верхний отступ
        add(applyFieldsButton, gbc);

        // Изначально поля и кнопка неактивны
        setFieldsEnabled(false);
    }

    /**
     * Обновляет значения в полях ввода на основе данных из {@link FractalState}.
     *
     * @param state Состояние фрактала, параметры которого нужно отобразить.
     *              Если null, поля будут очищены.
     */
    public void updateFields(FractalState state) {
        if (state == null) {
            clearFields();
            setFieldsEnabled(false); // Делаем неактивными при очистке
            return;
        }
        Viewport vp = state.getViewport();
        // Устанавливаем значения, не вызывая события редактирования
        minXField.setValue(vp.getMinX());
        maxXField.setValue(vp.getMaxX());
        minYField.setValue(vp.getMinY());
        maxYField.setValue(vp.getMaxY());
        iterationsField.setValue(state.getMaxIterations());
        // Делаем поля активными, так как есть данные
        setFieldsEnabled(true);
    }

    /**
     * Очищает все поля ввода.
     */
    public void clearFields() {
        minXField.setValue(null);
        maxXField.setValue(null);
        minYField.setValue(null);
        maxYField.setValue(null);
        iterationsField.setValue(null);
    }

    /**
     * Устанавливает состояние редактируемости для всех полей ввода и
     * состояние активности для кнопки "Применить".
     *
     * @param enabled {@code true}, чтобы разрешить редактирование и активировать кнопку,
     *                {@code false} - чтобы запретить и деактивировать.
     */
    public void setFieldsEnabled(boolean enabled) {
        minXField.setEditable(enabled);
        maxXField.setEditable(enabled);
        minYField.setEditable(enabled);
        maxYField.setEditable(enabled);
        iterationsField.setEditable(enabled);
        applyFieldsButton.setEnabled(enabled);
    }

    /**
     * Пытается прочитать и валидировать значения из полей ввода.
     *
     * @return Массив {@code Object[]}, где:
     *         <ul>
     *             <li>{@code [0]} - новый объект {@link Viewport}, созданный из полей X и Y.</li>
     *             <li>{@code [1]} - новое количество итераций ({@code Integer}).</li>
     *         </ul>
     * @throws ParseException Если не удалось распарсить значение в одном из полей.
     * @throws IllegalArgumentException Если введенные значения некорректны (например, minX >= maxX, итерации <= 0).
     * @throws NullPointerException Если значение одного из полей равно null после попытки commitEdit.
     */
    public Object[] getValidatedParameters() throws ParseException, IllegalArgumentException {
        // Принудительно завершаем редактирование, чтобы получить актуальные значения
        commitEditIfValid(minXField, "Min X");
        commitEditIfValid(maxXField, "Max X");
        commitEditIfValid(minYField, "Min Y");
        commitEditIfValid(maxYField, "Max Y");
        commitEditIfValid(iterationsField, "Итерации");

        // Чтение значений (теперь они должны быть корректного типа Number)
        double minX = ((Number) Objects.requireNonNull(minXField.getValue(), "Поле Min X пусто")).doubleValue();
        double maxX = ((Number) Objects.requireNonNull(maxXField.getValue(), "Поле Max X пусто")).doubleValue();
        double minY = ((Number) Objects.requireNonNull(minYField.getValue(), "Поле Min Y пусто")).doubleValue();
        double maxY = ((Number) Objects.requireNonNull(maxYField.getValue(), "Поле Max Y пусто")).doubleValue();
        int iterations = ((Number) Objects.requireNonNull(iterationsField.getValue(), "Поле Итерации пусто")).intValue();

        // Логическая валидация
        if (minX >= maxX) {
            throw new IllegalArgumentException("Значение Min X должно быть строго меньше Max X.");
        }
        if (minY >= maxY) {
            throw new IllegalArgumentException("Значение Min Y должно быть строго меньше Max Y.");
        }
        if (iterations <= 0) {
            throw new IllegalArgumentException("Количество итераций должно быть положительным числом (> 0).");
        }

        // Создание и возврат результатов
        Viewport viewport = new Viewport(minX, maxX, minY, maxY);
        return new Object[]{viewport, iterations};
    }

    /**
     * Вспомогательный метод для принудительного завершения редактирования поля.
     * @param field Поле для коммита.
     * @param fieldName Имя поля для сообщения об ошибке.
     * @throws ParseException если значение поля невалидно.
     */
    private void commitEditIfValid(JFormattedTextField field, String fieldName) throws ParseException {
        if (!field.isEditValid()) {
            throw new ParseException("Некорректное значение в поле '" + fieldName + "'", 0);
        }
        field.commitEdit(); // Применяет введенное значение
    }
}

// File: app/src/main/java/view/GenerationControlPanel.java

// File: app/src/main/java/view/GenerationControlPanel.java
package view;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionListener;

/**
 * Панель, содержащая элементы управления процессом генерации анимации:
 * кнопку запуска/отмены, индикатор прогресса и метку для отображения статуса.
 */
public class GenerationControlPanel extends JPanel {

    private final JButton generateButton;
    private final JProgressBar progressBar;
    private final JLabel statusLabel;

    /**
     * Создает панель управления генерацией анимации.
     *
     * @param generateOrCancelAction Слушатель {@link ActionListener}, который будет вызываться
     *                               при нажатии кнопки "Генерировать/Отмена".
     */
    public GenerationControlPanel(ActionListener generateOrCancelAction) {
        setLayout(new BorderLayout(5, 5)); // Используем BorderLayout

        // Кнопка Запуска/Отмены
        generateButton = new JButton("Генерировать видео...");
        generateButton.setToolTipText("Запустить процесс генерации видео или отменить текущий процесс");
        if (generateOrCancelAction != null) {
            generateButton.addActionListener(generateOrCancelAction);
        }

        // Индикатор прогресса
        progressBar = new JProgressBar(0, 100); // Диапазон от 0 до 100 %
        progressBar.setStringPainted(true); // Отображать текст (например, "50%")
        progressBar.setVisible(false); // Изначально скрыт, пока генерация не начнется

        // Метка статуса
        statusLabel = new JLabel("Готово к настройке.");
        statusLabel.setHorizontalAlignment(SwingConstants.LEFT); // Выравнивание текста по левому краю

        // Панель для статуса и прогресса (чтобы они были вместе)
        JPanel statusProgressPanel = new JPanel(new BorderLayout(5, 5));
        statusProgressPanel.add(statusLabel, BorderLayout.CENTER); // Статус занимает центр
        statusProgressPanel.add(progressBar, BorderLayout.SOUTH); // Прогресс-бар под статусом

        // Добавляем компоненты на основную панель
        add(generateButton, BorderLayout.NORTH); // Кнопка сверху
        add(statusProgressPanel, BorderLayout.CENTER); // Статус и прогресс в центре
    }

    /**
     * Обновляет текст в метке статуса. Потокобезопасно для вызова из любого потока.
     *
     * @param text Текст для отображения в статусной строке.
     */
    public void setStatus(String text) {
        // Обновляем метку в потоке диспетчеризации событий (EDT)
        if (SwingUtilities.isEventDispatchThread()) {
            statusLabel.setText(text);
        } else {
            SwingUtilities.invokeLater(() -> statusLabel.setText(text));
        }
    }

    /**
     * Возвращает текущий текст из метки статуса.
     *
     * @return Текст статуса.
     */
    public String getStatus() {
        return statusLabel.getText();
    }


    /**
     * Обновляет значение индикатора прогресса (от 0 до 100).
     * Потокобезопасно для вызова из любого потока.
     *
     * @param value Значение прогресса (0-100). Значения вне диапазона будут обрезаны.
     */
    public void setProgress(int value) {
        // Обновляем прогресс-бар в потоке EDT
        if (SwingUtilities.isEventDispatchThread()) {
            progressBar.setValue(value);
        } else {
            SwingUtilities.invokeLater(() -> progressBar.setValue(value));
        }
    }

    /**
     * Устанавливает видимость индикатора прогресса.
     * Потокобезопасно для вызова из любого потока.
     *
     * @param visible {@code true}, чтобы показать индикатор, {@code false} - чтобы скрыть.
     */
    public void setProgressVisible(boolean visible) {
        // Обновляем видимость в потоке EDT
        if (SwingUtilities.isEventDispatchThread()) {
            progressBar.setVisible(visible);
        } else {
            SwingUtilities.invokeLater(() -> progressBar.setVisible(visible));
        }
    }

    /**
     * Устанавливает текст на кнопке генерации/отмены.
     * Потокобезопасно для вызова из любого потока.
     *
     * @param text Текст для кнопки (например, "Генерировать видео..." или "Отмена").
     */
    public void setGenerateButtonText(String text) {
        // Обновляем текст кнопки в потоке EDT
        if (SwingUtilities.isEventDispatchThread()) {
            generateButton.setText(text);
        } else {
            SwingUtilities.invokeLater(() -> generateButton.setText(text));
        }
    }

    /**
     * Устанавливает состояние активности (enabled/disabled) для кнопки генерации/отмены.
     * Потокобезопасно для вызова из любого потока.
     *
     * @param enabled {@code true}, чтобы сделать кнопку активной, {@code false} - неактивной.
     */
    public void setGenerateButtonEnabled(boolean enabled) {
        // Обновляем состояние кнопки в потоке EDT
        if (SwingUtilities.isEventDispatchThread()) {
            generateButton.setEnabled(enabled);
        } else {
            SwingUtilities.invokeLater(() -> generateButton.setEnabled(enabled));
        }
    }
}

// File: app/src/main/java/view/KeyframePreviewPanel.java

// File: app/src/main/java/view/KeyframePreviewPanel.java
package view;

import model.FractalState;
import render.FractalRenderer;
import viewmodel.FractalViewModel;

import javax.swing.*;
import javax.swing.border.TitledBorder;
import java.awt.*;
import java.awt.event.ActionListener;
import java.util.Objects;

/**
 * Панель, предназначенная для интерактивного предпросмотра и редактирования
 * одного ключевого кадра анимации. Содержит {@link FractalPanel} с собственными
 * {@link FractalViewModel} и {@link FractalRenderer}, а также кнопки для загрузки
 * состояния выбранного кадра и для обновления выбранного кадра текущим состоянием предпросмотра.
 */
public class KeyframePreviewPanel extends JPanel {

    private final FractalPanel previewPanel;
    private final FractalViewModel previewViewModel;
    private final FractalRenderer previewRenderer;
    private final JButton loadToPreviewButton;
    private final JButton updateKeyframeButton;

    /**
     * Создает панель предпросмотра ключевого кадра.
     *
     * @param loadAction Слушатель {@link ActionListener} для кнопки "Загрузить сюда".
     *                   Вызывается, когда пользователь хочет загрузить состояние
     *                   выбранного в списке кадра в эту панель.
     * @param updateAction Слушатель {@link ActionListener} для кнопки "Обновить кадр из предпросмотра".
     *                     Вызывается, когда пользователь хочет обновить выбранный в списке
     *                     кадр текущим состоянием этой панели предпросмотра.
     */
    public KeyframePreviewPanel(ActionListener loadAction, ActionListener updateAction) {
        setLayout(new BorderLayout(5, 5));
        setBorder(new TitledBorder("Предпросмотр и интерактивное редактирование"));

        // Создание изолированных компонентов для предпросмотра
        previewRenderer = new FractalRenderer();
        previewViewModel = new FractalViewModel(previewRenderer, 1); // История Undo не нужна (1 - минимально)
        previewPanel = new FractalPanel(previewViewModel, previewRenderer);
        // Устанавливаем предпочтительный размер для панели предпросмотра
        previewPanel.setPreferredSize(new Dimension(450, 350));

        add(previewPanel, BorderLayout.CENTER);

        // Кнопки управления
        loadToPreviewButton = new JButton("Загрузить сюда");
        loadToPreviewButton.setToolTipText("Загружает состояние выбранного в списке кадра в эту панель");
        loadToPreviewButton.setEnabled(false); // Активна только при выборе кадра в списке
        if (loadAction != null) {
            loadToPreviewButton.addActionListener(loadAction);
        }

        updateKeyframeButton = new JButton("Обновить кадр из предпросмотра");
        updateKeyframeButton.setToolTipText("Обновляет выбранный в списке кадр текущим состоянием этой панели");
        updateKeyframeButton.setEnabled(false); // Активна только при выборе кадра в списке
        if (updateAction != null) {
            updateKeyframeButton.addActionListener(updateAction);
        }

        JPanel buttonsPanel = new JPanel(new FlowLayout(FlowLayout.CENTER));
        buttonsPanel.add(loadToPreviewButton);
        buttonsPanel.add(updateKeyframeButton);
        add(buttonsPanel, BorderLayout.SOUTH);
    }

    /**
     * Загружает указанное состояние фрактала в {@link FractalViewModel} этой панели предпросмотра.
     * Это вызовет перерисовку {@link FractalPanel}.
     *
     * @param state Состояние {@link FractalState} для загрузки и отображения. Если null,
     *              панель может отобразить состояние по умолчанию или остаться пустой (текущая реализация ViewModel загрузит дефолт).
     */
    public void loadState(FractalState state) {
        previewViewModel.loadState(Objects.requireNonNullElseGet(state, FractalState::createDefault));
        // Если state == null, загружаем состояние по умолчанию
    }

    /**
     * Возвращает текущее состояние фрактала, отображаемое в панели предпросмотра.
     *
     * @return Текущий {@link FractalState} из {@link FractalViewModel} предпросмотра.
     */
    public FractalState getCurrentState() {
        return previewViewModel.getCurrentState();
    }

    /**
     * Устанавливает состояние активности (enabled/disabled) для кнопок
     * "Загрузить сюда" и "Обновить кадр из предпросмотра".
     * Обычно вызывается при изменении выбора в списке ключевых кадров.
     *
     * @param enabled {@code true}, чтобы сделать кнопки активными, {@code false} - неактивными.
     */
    public void setControlButtonsEnabled(boolean enabled) {
        loadToPreviewButton.setEnabled(enabled);
        updateKeyframeButton.setEnabled(enabled);
    }

    /**
     * Останавливает потоки рендерера {@link FractalRenderer}, связанного с этой панелью предпросмотра.
     * Этот метод **необходимо** вызывать при закрытии родительского окна или диалога,
     * чтобы предотвратить утечку ресурсов и потоков.
     */
    public void shutdownRenderer() {
        System.out.println("Завершение работы рендерера предпросмотра (из KeyframePreviewPanel)...");
        if (previewRenderer != null) {
            previewRenderer.shutdown();
        }
        System.out.println("Рендерер предпросмотра остановлен (из KeyframePreviewPanel).");
    }
}

// File: app/src/main/java/view/JuliaSetWindow.java

// File: app/src/main/java/view/JuliaSetWindow.java
package view;

import math.FractalFunction;
import math.JuliaFunction;
import model.ColorScheme;
import model.FractalState;
import model.Viewport;
import render.FractalRenderer;
import utils.ComplexNumber;
import viewmodel.FractalViewModel;
import services.FileService; // Импорт для возможного меню сохранения

import javax.swing.*;
import java.awt.*;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;

/**
 * Окно JFrame, предназначенное для отображения множества Жюлиа.
 * Множество Жюлиа определяется комплексным параметром 'c', который обычно
 * соответствует точке, выбранной пользователем в основном окне множества Мандельброта.
 * Использует собственные экземпляры {@link FractalViewModel} и {@link FractalRenderer}.
 */
public class JuliaSetWindow extends JFrame {

    /** Независимый ViewModel для управления состоянием этого окна Жюлиа. */
    private final FractalViewModel viewModel;
    /** Независимый рендерер для отрисовки множества Жюлиа в этом окне. */
    private final FractalRenderer renderer;
    /** Панель для отрисовки фрактала Жюлиа, использующая свои viewModel и renderer. */
    private final FractalPanel fractalPanel;
    /**
     * Комплексный параметр 'c', определяющий конкретное множество Жюлиа,
     * отображаемое в этом окне. Является константой для {@link JuliaFunction}.
     */
    private final ComplexNumber c;

    /**
     * Создает новое окно для отображения множества Жюлиа.
     * Инициализирует независимые компоненты рендеринга и управления состоянием.
     * Устанавливает начальное состояние (viewport, итерации, схема) на основе
     * параметров, переданных из основного окна.
     *
     * @param ownerFrame       Родительское окно (обычно {@link MainFrame}), используется
     *                         для позиционирования этого окна. Может быть null.
     * @param c                Комплексный параметр 'c' для функции множества Жюлиа {@link JuliaFunction}. Не может быть null.
     * @param initialColorScheme Начальная цветовая схема, унаследованная из основного окна. Не может быть null.
     * @param initialIterations Начальное максимальное количество итераций, унаследованное из основного окна. Должно быть > 0.
     */
    public JuliaSetWindow(JFrame ownerFrame, ComplexNumber c, ColorScheme initialColorScheme, int initialIterations) {
        // Формируем заголовок окна, отображающий значение 'c'
        super("Julia Set Explorer (c = " + String.format("%.4f %s %.4fi",
                c.getReal(), c.getImaginary() >= 0 ? "+" : "-", Math.abs(c.getImaginary())) + ")");
        this.c = c;

        // Создаем НЕЗАВИСИМЫЕ экземпляры рендерера и ViewModel для этого окна
        this.renderer = new FractalRenderer();
        this.viewModel = new FractalViewModel(renderer);

        // Создаем начальное состояние специально для множества Жюлиа
        FractalState juliaState = createInitialJuliaState(c, initialColorScheme, initialIterations);
        // Загружаем это состояние в ViewModel окна Жюлиа. Это сбрасывает историю Undo.
        this.viewModel.loadState(juliaState);

        // Создаем панель отрисовки, передавая ей НЕЗАВИСИМЫЕ viewModel и renderer
        this.fractalPanel = new FractalPanel(viewModel, renderer);

        // Настройка окна
        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE); // Закрывать только это окно, не всё приложение
        setSize(600, 500);                                // Начальный размер окна
        setLocationRelativeTo(ownerFrame);                // Позиционировать относительно родительского окна (или по центру экрана, если ownerFrame == null)
        setLayout(new BorderLayout());                    // Используем BorderLayout
        add(fractalPanel, BorderLayout.CENTER);           // Добавляем панель отрисовки в центр

        // Добавляем слушатель для корректного завершения работы рендерера при закрытии окна
        addWindowListener(new WindowAdapter() {
            /**
             * Вызывается перед закрытием окна. Останавливает потоки рендерера,
             * связанного с этим окном, чтобы предотвратить утечку ресурсов.
             * @param e Событие окна.
             */
            @Override
            public void windowClosing(WindowEvent e) {
                System.out.println("Shutting down Julia set renderer...");
                // Останавливаем ExecutorService рендерера этого окна
                renderer.shutdown();
                System.out.println("Julia set renderer shut down for c=" + JuliaSetWindow.this.c);
            }
        });

        // Опционально: можно добавить собственное меню для окна Жюлиа
        // Например, только для сохранения изображения
        // MenuBar juliaMenuBar = createJuliaMenuBar();
        // setJMenuBar(juliaMenuBar);

        System.out.println("Julia Set window created for c = " + c);
    }

    /**
     * Создает начальный объект {@link FractalState} для отображения множества Жюлиа.
     * Устанавливает viewport по умолчанию для Жюлиа (обычно [-2, 2] x [-2, 2]),
     * использует переданные цветовую схему и количество итераций, и создает
     * экземпляр {@link JuliaFunction} с заданным параметром 'c'.
     *
     * @param cParam           Параметр 'c' для {@link JuliaFunction}.
     * @param colorScheme      Цветовая схема для рендеринга.
     * @param maxIterations    Максимальное количество итераций.
     * @return Начальное состояние {@link FractalState} для окна Жюлиа.
     */
    private FractalState createInitialJuliaState(ComplexNumber cParam, ColorScheme colorScheme, int maxIterations) {
        // Стандартная область просмотра для большинства множеств Жюлиа
        Viewport juliaViewport = new Viewport(-2.0, 2.0, -2.0, 2.0);
        // Создаем функцию расчета итераций для множества Жюлиа с нашим параметром 'c'
        FractalFunction juliaFunction = new JuliaFunction(cParam);

        // Создаем объект состояния
        return new FractalState(juliaViewport, maxIterations, colorScheme, juliaFunction);
    }

    // Опционально: Метод для создания упрощенного меню для окна Жюлиа
    /*
    private MenuBar createJuliaMenuBar() {
        // Создаем FileService локально или получаем извне, если нужно
        FileService localFileService = new FileService();
        // Создаем MenuBar, передавая *локальные* viewModel, fractalPanel и это окно (this)
        MenuBar juliaMenu = new MenuBar(this.viewModel, localFileService, this.fractalPanel, this);

        // Удаляем ненужные пункты меню (например, Load State, Edit->Undo, View->Scheme/Iterations)
        // Меню File (индекс 0)
        JMenu fileMenu = juliaMenu.getMenu(0);
        if (fileMenu != null) {
            // Удаляем Load, Save State, Separator, Exit (оставляем только Save As Image)
             if (fileMenu.getItemCount() > 2) fileMenu.remove(0); // Load
             if (fileMenu.getItemCount() > 2) fileMenu.remove(0); // Save State (из Save As)
             if (fileMenu.getItemCount() > 1) fileMenu.remove(1); // Separator
             if (fileMenu.getItemCount() > 1) fileMenu.remove(1); // Exit
        }
        // Удаляем меню Edit (индекс 1)
        if (juliaMenu.getMenuCount() > 1) juliaMenu.remove(1);
        // Удаляем меню View (индекс 1 после удаления Edit)
        if (juliaMenu.getMenuCount() > 1) juliaMenu.remove(1);

        return juliaMenu;
    }
    */


    /**
     * Делает окно множества Жюлиа видимым.
     * После вызова этого метода панель {@link FractalPanel} получит события
     * {@code componentShown} или {@code componentResized}, что инициирует
     * первый запуск рендеринга.
     */
    public void display() {
        setVisible(true);
        // Первый рендер запустится автоматически панелью FractalPanel
    }
}

// File: app/src/main/java/view/MainFrame.java

package view;

import render.FractalRenderer;
import services.FileService;
import viewmodel.FractalViewModel;

import javax.swing.*;
import java.awt.*;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;

/**
 * Главное окно приложения "Mandelbrot Set Explorer".
 * Содержит основную панель для отрисовки фрактала ({@link FractalPanel})
 * и главное меню ({@link MenuBar}). Инициализирует ключевые компоненты
 * архитектуры: {@link FractalViewModel}, {@link FractalRenderer}, {@link FileService}.
 * Обрабатывает событие закрытия окна для корректного завершения работы.
 */
public class MainFrame extends JFrame {

    /** ViewModel, управляющая состоянием фрактала Мандельброта. */
    private final FractalViewModel viewModel;
    /** Рендерер, отвечающий за вычисление и отрисовку фрактала. */
    private final FractalRenderer renderer;
    /** Сервис для операций с файлами (сохранение/загрузка состояния и изображений). */
    private final FileService fileService;
    /** Панель, отображающая фрактал и обрабатывающая ввод пользователя. */
    private final FractalPanel fractalPanel;

    /**
     * Конструирует главное окно приложения.
     * Инициализирует ViewModel, Renderer, FileService, FractalPanel и MenuBar.
     * Настраивает основные параметры окна (заголовок, операция закрытия по умолчанию,
     * расположение) и добавляет слушатель для обработки закрытия окна.
     */
    public MainFrame() {
        // Инициализация основных компонентов
        renderer = new FractalRenderer();
        viewModel = new FractalViewModel(renderer); // ViewModel для Мандельброта
        fileService = new FileService();

        // Настройка окна
        setTitle("Mandelbrot Set Explorer");
        // Устанавливаем DO_NOTHING_ON_CLOSE, чтобы обработать закрытие в windowClosing
        setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
        setLocationRelativeTo(null); // Центрировать окно на экране

        // Создание и настройка компонентов GUI
        fractalPanel = new FractalPanel(viewModel, renderer); // Панель для Мандельброта
        MenuBar menuBar = new MenuBar(viewModel, fileService, fractalPanel, this);

        // Сборка интерфейса
        setJMenuBar(menuBar);
        add(fractalPanel, BorderLayout.CENTER); // Добавляем панель в центр окна
        pack(); // Устанавливает размер окна на основе предпочтительных размеров компонентов

        // Добавляем слушатель для обработки события закрытия окна
        addWindowListener(new WindowAdapter() {
            /**
             * Вызывается, когда пользователь пытается закрыть окно (нажимает крестик).
             * Вызывает метод {@link #handleWindowClose()} для подтверждения
             * и корректного завершения работы.
             * @param e Событие окна.
             */
            @Override
            public void windowClosing(WindowEvent e) {
                handleWindowClose();
            }
        });
    }

    /**
     * Обрабатывает попытку закрытия главного окна.
     * Показывает диалог подтверждения. Если пользователь подтверждает выход,
     * останавливает потоки рендерера, освобождает ресурсы окна и завершает приложение.
     */
    private void handleWindowClose() {
        // Показываем диалог подтверждения
        int confirmation = JOptionPane.showConfirmDialog(
                this, // Родительский компонент для диалога
                "Are you sure you want to exit?", // Сообщение
                "Confirm Exit", // Заголовок диалога
                JOptionPane.YES_NO_OPTION, // Кнопки Да/Нет
                JOptionPane.QUESTION_MESSAGE // Иконка вопроса
        );

        // Если пользователь нажал "Да"
        if (confirmation == JOptionPane.YES_OPTION) {
            System.out.println("Shutting down renderer...");
            // Корректно останавливаем ExecutorService рендерера
            renderer.shutdown();
            System.out.println("Exiting application.");
            // Освобождаем ресурсы окна
            dispose();
            // Завершаем работу JVM
            System.exit(0);
        }
        // Если пользователь нажал "Нет", ничего не делаем, окно остается открытым
    }

    /**
     * Главный метод, точка входа в приложение.
     * Устанавливает системный Look and Feel для нативного вида интерфейса
     * и запускает создание и отображение главного окна в потоке
     * диспетчеризации событий Swing (EDT).
     *
     * @param args Аргументы командной строки (не используются).
     */
    public static void main(String[] args) {
        // Попытка установить системный стиль интерфейса для лучшего внешнего вида
        try {
            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
        } catch (Exception e) {
            // В случае ошибки просто выводим сообщение, приложение продолжит работу со стилем по умолчанию
            System.err.println("Couldn't set system look and feel: " + e.getMessage());
        }

        // Запускаем создание и отображение GUI в потоке диспетчеризации событий (EDT)
        // Это стандартная практика для работы со Swing для обеспечения потокобезопасности
        SwingUtilities.invokeLater(() -> {
            MainFrame frame = new MainFrame();
            frame.setVisible(true); // Делаем окно видимым
        });
    }
}

// File: app/src/main/java/listeners/MousePanListener.java

package listeners;

import viewmodel.FractalViewModel; // core

import javax.swing.JPanel;
import javax.swing.SwingUtilities;
import java.awt.Cursor;
import java.awt.Point;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionListener;

/**
 * Обрабатывает панорамирование (перемещение) вида фрактала с помощью
 * перетаскивания правой кнопки мыши.
 * Реализует {@link MouseAdapter} и {@link MouseMotionListener}.
 */
public class MousePanListener extends MouseAdapter implements MouseMotionListener {

    /** ViewModel для доступа к состоянию и выполнения панорамирования. */
    private final FractalViewModel viewModel;
    /** Панель, на которой отслеживаются события мыши. */
    private final JPanel panel;
    /** Последняя зафиксированная точка мыши во время перетаскивания. */
    private Point lastPoint = null;
    /** Исходный курсор панели до начала панорамирования. */
    private Cursor originalCursor; // Исходный курсор панели

    /**
     * Создает слушателя для панорамирования.
     * @param viewModel ViewModel приложения. Не может быть null.
     * @param panel Панель, на которой будут отслеживаться события. Не может быть null.
     */
    public MousePanListener(FractalViewModel viewModel, JPanel panel) {
        this.viewModel = viewModel;
        this.panel = panel;
    }

    /**
     * Вызывается при нажатии кнопки мыши.
     * Если нажата правая кнопка, запоминает начальную точку,
     * сохраняет текущий курсор и устанавливает курсор перемещения.
     * @param e Событие мыши.
     */
    @Override
    public void mousePressed(MouseEvent e) {
        // Начинаем панорамирование только правой кнопкой (или средней, если хотим)
        if (SwingUtilities.isRightMouseButton(e)) {
            // ИЛИ: if (e.getButton() == MouseEvent.BUTTON3) { // Более явно
            lastPoint = e.getPoint();
            originalCursor = panel.getCursor(); // Сохраняем текущий курсор
            panel.setCursor(Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR));
            e.consume(); // Поглощаем событие, чтобы оно не обрабатывалось другими слушателями (например, Zoom)
        }
    }

    /**
     * Вызывается при перетаскивании мыши с нажатой кнопкой.
     * Если нажата правая кнопка и панорамирование начато, вычисляет смещение (deltaX, deltaY)
     * и вызывает метод {@link FractalViewModel#panOnScreenDelta(int, int, int, int)} для обновления вида.
     * @param e Событие мыши.
     */
    @Override
    public void mouseDragged(MouseEvent e) {
        // Продолжаем панорамирование, если нажата правая кнопка и есть начальная точка
        if (SwingUtilities.isRightMouseButton(e) && lastPoint != null) {
            Point currentPoint = e.getPoint();
            int deltaX = currentPoint.x - lastPoint.x;
            int deltaY = currentPoint.y - lastPoint.y;

            if (deltaX != 0 || deltaY != 0) {
                if (panel.getWidth() > 0 && panel.getHeight() > 0) {
                    // Вызываем метод ViewModel для панорамирования
                    viewModel.panOnScreenDelta(deltaX, deltaY, panel.getWidth(), panel.getHeight());
                }
                // Обновляем lastPoint для следующего шага перетаскивания
                lastPoint = currentPoint;
            }
            e.consume(); // Поглощаем событие
        }
    }

    /**
     * Вызывается при отпускании кнопки мыши.
     * Если была отпущена правая кнопка и выполнялось панорамирование,
     * восстанавливает исходный курсор и сбрасывает состояние панорамирования.
     * @param e Событие мыши.
     */
    @Override
    public void mouseReleased(MouseEvent e) {
        // Завершаем панорамирование при отпускании правой кнопки
        if (e.getButton() == MouseEvent.BUTTON3) { // Проверяем явно правую кнопку
            if (lastPoint != null) {
                panel.setCursor(originalCursor); // Восстанавливаем исходный курсор
                lastPoint = null; // Сбрасываем состояние
                originalCursor = null;
            }
            e.consume(); // Поглощаем событие
        }
    }

    /**
     * Метод интерфейса {@link MouseMotionListener}. Не используется в данной реализации.
     * @param e Событие мыши.
     */
    @Override
    public void mouseMoved(MouseEvent e) { }
}

// File: app/src/main/java/listeners/MouseZoomListener.java

// File: app/src/main/java/listeners/MouseZoomListener.java
package listeners;

import viewmodel.FractalViewModel;

import javax.swing.JPanel;
import javax.swing.SwingUtilities;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionListener;

/**
 * Обрабатывает масштабирование (зум) в выделенную прямоугольную область
 * с помощью перетаскивания левой кнопки мыши.
 * Также отвечает за отрисовку прямоугольника выделения на панели.
 * Реализует {@link MouseAdapter} и {@link MouseMotionListener}.
 */
public class MouseZoomListener extends MouseAdapter implements MouseMotionListener {

    /** ViewModel для доступа к состоянию и выполнения масштабирования. */
    private final FractalViewModel viewModel;
    /** Панель, на которой отслеживаются события и рисуется прямоугольник выделения. */
    private final JPanel panel;
    /** Начальная точка выделения при нажатии левой кнопки мыши. */
    private Point startPoint = null;
    /** Конечная точка выделения (текущая позиция мыши при перетаскивании). */
    private Point endPoint = null;
    /** Минимальный размер стороны прямоугольника в пикселях, чтобы зум сработал. */
    private static final int MIN_ZOOM_SIZE = 5;


    /**
     * Создает слушателя для масштабирования выделением.
     * @param viewModel ViewModel приложения. Не может быть null.
     * @param panel Панель, на которой будут отслеживаться события. Не может быть null.
     */
    public MouseZoomListener(FractalViewModel viewModel, JPanel panel) {
        this.viewModel = viewModel;
        this.panel = panel;
    }

    /**
     * Вызывается при нажатии кнопки мыши.
     * Если нажата левая кнопка, запоминает начальную точку выделения
     * и инициирует перерисовку панели (для возможного отображения начальной точки).
     * @param e Событие мыши.
     */
    @Override
    public void mousePressed(MouseEvent e) {
        // Начинаем выделение левой кнопкой
        if (SwingUtilities.isLeftMouseButton(e)) {
            startPoint = e.getPoint();
            endPoint = startPoint; // Начинаем с точки
            panel.repaint(); // Перерисовать, чтобы показать начало (если нужно)
        }
    }

    /**
     * Вызывается при перетаскивании мыши с нажатой кнопкой.
     * Если нажата левая кнопка и выделение начато, обновляет конечную точку
     * и инициирует перерисовку панели для отображения прямоугольника выделения.
     * @param e Событие мыши.
     */
    @Override
    public void mouseDragged(MouseEvent e) {
        // Обновляем конечную точку и перерисовываем прямоугольник выделения
        if (SwingUtilities.isLeftMouseButton(e) && startPoint != null) {
            endPoint = e.getPoint();
            panel.repaint(); // Перерисовать панель, чтобы показать прямоугольник
        }
    }

    /**
     * Вызывается при отпускании кнопки мыши.
     * Если была отпущена левая кнопка, выделение было начато и конечная точка установлена,
     * проверяет, имеет ли выделенный прямоугольник достаточный размер.
     * Если да, вызывает метод {@link FractalViewModel#zoomOnScreenRect(int, int, int, int, int, int)}
     * для выполнения масштабирования. Затем сбрасывает состояние выделения и инициирует
     * перерисовку для удаления прямоугольника.
     * @param e Событие мыши.
     */
    @Override
    public void mouseReleased(MouseEvent e) {
        // Завершаем выделение и зумируем, если прямоугольник валидный
        if (SwingUtilities.isLeftMouseButton(e) && startPoint != null && endPoint != null) {
            int x1 = startPoint.x;
            int y1 = startPoint.y;
            int x2 = endPoint.x;
            int y2 = endPoint.y;

            // Сбрасываем точки для следующего раза и для отрисовки
            startPoint = null;
            endPoint = null;
            panel.repaint(); // Убрать прямоугольник выделения

            // Проверяем минимальный размер
            if (Math.abs(x1 - x2) >= MIN_ZOOM_SIZE && Math.abs(y1 - y2) >= MIN_ZOOM_SIZE) {
                // Вызываем метод ViewModel для зума
                viewModel.zoomOnScreenRect(x1, y1, x2, y2, panel.getWidth(), panel.getHeight());
            }
        }
    }

    /**
     * Рисует прямоугольник выделения на предоставленном графическом контексте.
     * Вызывается из метода {@code paintComponent} панели {@link #panel}.
     * Рисует прямоугольник только если выделение активно ({@code startPoint} и {@code endPoint} не null).
     * Использует белую пунктирную линию.
     *
     * @param g Графический контекст панели для отрисовки.
     */
    public void drawSelectionRectangle(Graphics g) {
        if (startPoint != null && endPoint != null) {
            Graphics2D g2d = (Graphics2D) g.create(); // Создаем копию, чтобы не менять настройки Graphics
            try { // Используем try-finally для гарантированного dispose()
                g2d.setColor(Color.WHITE); // Цвет рамки
                // Используем XOR режим для инвертирования цветов под рамкой (не всегда хорошо работает)
                // g2d.setXORMode(Color.BLACK);

                // Устанавливаем штриховую линию
                g2d.setStroke(new BasicStroke(1, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER,
                                              10.0f, new float[]{3.0f}, 0.0f));


                int x = Math.min(startPoint.x, endPoint.x);
                int y = Math.min(startPoint.y, endPoint.y);
                int width = Math.abs(startPoint.x - endPoint.x);
                int height = Math.abs(startPoint.y - endPoint.y);

                g2d.drawRect(x, y, width, height);
            } finally {
                 g2d.dispose(); // Освобождаем копию Graphics
            }
        }
    }

    /**
     * Метод интерфейса {@link MouseMotionListener}. Не используется в данной реализации.
     * @param e Событие мыши.
     */
    @Override
    public void mouseMoved(MouseEvent e) {
        // Не используется для зума
    }
}

// File: core/src/main/java/model/GrayscaleScheme.java

// File: core/src/main/java/model/GrayscaleScheme.java
package model;

import java.awt.Color;
import java.io.Serializable; // Импорт добавлен для полноты

/**
 * Простая цветовая схема в оттенках серого для визуализации фракталов.
 * Точки, принадлежащие множеству (достигшие максимального числа итераций), окрашиваются в черный цвет.
 * Точки вне множества окрашиваются в градации серого: от белого (для точек, "убежавших" быстро,
 * т.е. с малым числом итераций) до почти черного (для точек, "убежавших" медленно,
 * т.е. с числом итераций, близким к максимальному).
 * Реализует интерфейс {@link ColorScheme} и {@link Serializable}.
 */
public class GrayscaleScheme implements ColorScheme {
    /**
     * Версия для сериализации. Важна для совместимости при сохранении/загрузке состояния.
     */
    private static final long serialVersionUID = 1L;

    /**
     * {@inheritDoc}
     * Возвращает цвет пикселя на основе количества итераций.
     * <ul>
     *     <li>Если {@code iterations >= maxIterations} (точка внутри множества) или {@code maxIterations <= 1} (некорректный предел), возвращает {@link Color#BLACK}.</li>
     *     <li>В противном случае, вычисляет оттенок серого. Используется линейная интерполяция:
     *         значение серого = 255 * (1 - (iterations / (maxIterations - 1))).
     *         Это обеспечивает плавный переход от белого (iterations=0) к темно-серому (iterations=maxIterations-1).</li>
     * </ul>
     *
     * @param iterations    Количество итераций, выполненных для точки.
     * @param maxIterations Максимальное количество итераций, заданное для рендеринга.
     * @return Вычисленный цвет {@link Color} в оттенках серого или черный.
     */
    @Override
    public Color getColor(int iterations, int maxIterations) {
        // Точка внутри множества или некорректный maxIterations
        if (iterations >= maxIterations || maxIterations <= 1) {
            return Color.BLACK;
        }

        // Линейная интерполяция от белого (мало итераций) к почти черному (много итераций).
        // Используем (maxIterations - 1.0) в знаменателе для корректной обработки диапазона [0, maxIterations-1].
        // Используем double для точности вычислений.
        double ratio = (double) iterations / (maxIterations - 1.0);

        // Инвертируем отношение (1.0 - ratio), чтобы 0 итераций давал белый цвет (255),
        // а maxIterations - 1 давал почти черный (близкий к 0).
        // Умножаем на 255 и преобразуем в int.
        int gray = (int) (255.0 * (1.0 - ratio));

        // Ограничиваем значения диапазоном [0, 255] на случай ошибок округления или граничных значений.
        gray = Math.min(255, Math.max(0, gray));

        return new Color(gray, gray, gray);
    }

    /**
     * {@inheritDoc}
     * Возвращает имя этой цветовой схемы для отображения в пользовательском интерфейсе.
     * @return Строка "Grayscale".
     */
    @Override
    public String getName() {
        return "Grayscale"; // Название схемы для UI
    }

    /**
     * Сравнивает эту цветовую схему с другим объектом.
     * Две {@code GrayscaleScheme} считаются равными, так как у них нет настраиваемых параметров.
     * @param obj Объект для сравнения.
     * @return {@code true}, если {@code obj} является экземпляром {@code GrayscaleScheme}, иначе {@code false}.
     */
    @Override
    public boolean equals(Object obj) {
        // Проверка на null и на совпадение класса
        if (this == obj) return true; // Оптимизация: если это тот же объект
        return obj != null && getClass() == obj.getClass(); // Достаточно сравнить классы
    }

    /**
     * Возвращает хэш-код для этой цветовой схемы.
     * Так как все экземпляры {@code GrayscaleScheme} эквивалентны,
     * хэш-код основан только на классе.
     * @return Хэш-код, соответствующий классу {@code GrayscaleScheme}.
     */
    @Override
    public int hashCode() {
        // Хэш-код одинаков для всех экземпляров этого класса.
        return GrayscaleScheme.class.hashCode();
    }
}

// File: core/src/main/java/model/FractalState.java

// File: core/src/main/java/model/FractalState.java
package model;

import math.FractalFunction; // <-- Добавлен импорт
import math.MandelbrotFunction; // <-- Добавлен импорт для дефолтной функции
import java.io.Serializable;
import java.util.Objects;

/**
 * Представляет полное, неизменяемое (immutable) состояние визуализации фрактала
 * в определенный момент времени. Инкапсулирует все параметры, необходимые
 * для рендеринга и описания текущего вида.
 * <p>
 * Включает:
 * <ul>
 *     <li>{@link Viewport}: Область комплексной плоскости для отображения.</li>
 *     <li>{@code maxIterations}: Максимальное количество итераций для расчета принадлежности точки множеству.</li>
 *     <li>{@link ColorScheme}: Цветовая схема для окрашивания точек в зависимости от числа итераций.</li>
 *     <li>{@link FractalFunction}: Функция, определяющая правило расчета итераций (например, для Мандельброта или Жюлиа).</li>
 * </ul>
 * Объекты этого класса предназначены для передачи между компонентами (ViewModel, View, Renderer)
 * и для сохранения/загрузки состояния приложения (так как реализует {@link Serializable}).
 */
public final class FractalState implements Serializable {
    /**
     * Версия для сериализации. Увеличена до 2 из-за добавления поля {@code fractalFunction}.
     */
    private static final long serialVersionUID = 2L;

    /** Текущая область просмотра комплексной плоскости. */
    private final Viewport viewport;
    /** Максимальное количество итераций для расчета. */
    private final int maxIterations;
    /** Активная цветовая схема. */
    private final ColorScheme colorScheme;
    /** Функция, используемая для расчета количества итераций фрактала. */
    private final FractalFunction fractalFunction;

    /** Экземпляр функции Мандельброта по умолчанию, используемый в {@link #createDefault()}. */
    private static final FractalFunction DEFAULT_FRACTAL_FUNCTION = new MandelbrotFunction();

    /**
     * Создает новый экземпляр состояния фрактала с заданными параметрами.
     * Выполняет проверку аргументов на null и корректность {@code maxIterations}.
     *
     * @param viewport        Текущая область просмотра. Не может быть null.
     * @param maxIterations   Максимальное количество итераций. Должно быть положительным числом (> 0).
     * @param colorScheme     Цветовая схема для рендеринга. Не может быть null.
     * @param fractalFunction Функция расчета фрактала. Не может быть null.
     * @throws NullPointerException если {@code viewport}, {@code colorScheme} или {@code fractalFunction} равны null.
     * @throws IllegalArgumentException если {@code maxIterations} не является положительным числом.
     */
    public FractalState(Viewport viewport, int maxIterations, ColorScheme colorScheme, FractalFunction fractalFunction) {
        this.viewport = Objects.requireNonNull(viewport, "Viewport не может быть null");
        this.colorScheme = Objects.requireNonNull(colorScheme, "Цветовая схема не может быть null");
        this.fractalFunction = Objects.requireNonNull(fractalFunction, "Функция фрактала не может быть null");

        if (maxIterations <= 0) {
            throw new IllegalArgumentException("Максимальное количество итераций должно быть положительным");
        }
        this.maxIterations = maxIterations;
    }

    // --- Геттеры ---

    /**
     * Возвращает текущую область просмотра.
     * @return {@link Viewport} состояния.
     */
    public Viewport getViewport() {
        return viewport;
    }

    /**
     * Возвращает максимальное количество итераций.
     * @return Максимальное количество итераций.
     */
    public int getMaxIterations() {
        return maxIterations;
    }

    /**
     * Возвращает активную цветовую схему.
     * @return {@link ColorScheme} состояния.
     */
    public ColorScheme getColorScheme() {
        return colorScheme;
    }

    /**
     * Возвращает активную функцию расчета фрактала.
     * @return {@link FractalFunction} состояния.
     */
    public FractalFunction getFractalFunction() {
        return fractalFunction;
    }

    // --- Методы для создания нового состояния с изменениями (immutable pattern) ---

    /**
     * Создает новый экземпляр {@code FractalState} с измененной областью просмотра.
     * Остальные параметры (итерации, схема, функция) копируются из текущего состояния.
     *
     * @param newViewport Новая область просмотра {@link Viewport}. Не может быть null.
     * @return Новый экземпляр {@code FractalState} с указанным {@code Viewport}.
     */
    public FractalState withViewport(Viewport newViewport) {
        return new FractalState(newViewport, this.maxIterations, this.colorScheme, this.fractalFunction);
    }

    /**
     * Создает новый экземпляр {@code FractalState} с измененным максимальным количеством итераций.
     * Остальные параметры (viewport, схема, функция) копируются из текущего состояния.
     *
     * @param newMaxIterations Новое максимальное количество итераций. Должно быть > 0.
     * @return Новый экземпляр {@code FractalState} с указанным количеством итераций.
     */
    public FractalState withMaxIterations(int newMaxIterations) {
        return new FractalState(this.viewport, newMaxIterations, this.colorScheme, this.fractalFunction);
    }

    /**
     * Создает новый экземпляр {@code FractalState} с измененной цветовой схемой.
     * Остальные параметры (viewport, итерации, функция) копируются из текущего состояния.
     *
     * @param newColorScheme Новая цветовая схема {@link ColorScheme}. Не может быть null.
     * @return Новый экземпляр {@code FractalState} с указанной цветовой схемой.
     */
    public FractalState withColorScheme(ColorScheme newColorScheme) {
        return new FractalState(this.viewport, this.maxIterations, newColorScheme, this.fractalFunction);
    }

    /**
     * Создает новый экземпляр {@code FractalState} с измененной функцией расчета фрактала.
     * Остальные параметры (viewport, итерации, схема) копируются из текущего состояния.
     *
     * @param newFractalFunction Новая функция расчета {@link FractalFunction}. Не может быть null.
     * @return Новый экземпляр {@code FractalState} с указанной функцией фрактала.
     */
    public FractalState withFractalFunction(FractalFunction newFractalFunction) {
        return new FractalState(this.viewport, this.maxIterations, this.colorScheme, newFractalFunction);
    }


    // --- Стандартные методы Object ---

    /**
     * Сравнивает это состояние фрактала с другим объектом на равенство.
     * Два состояния считаются равными, если у них совпадают:
     * <ul>
     *     <li>Область просмотра ({@code viewport})</li>
     *     <li>Максимальное количество итераций ({@code maxIterations})</li>
     *     <li>Класс цветовой схемы ({@code colorScheme.getClass()})</li>
     *     <li>Функция фрактала ({@code fractalFunction}) - сравнение через {@code equals} функции</li>
     * </ul>
     * Сравнение цветовой схемы и функции по классу/equals важно для корректной работы Undo/Redo
     * и избежания лишних перерисовок, если меняется только экземпляр, но не суть схемы/функции.
     * Для функций с параметрами (как {@link math.JuliaFunction}) их {@code equals} должен сравнивать эти параметры.
     *
     * @param o Объект для сравнения.
     * @return {@code true}, если объекты семантически равны, иначе {@code false}.
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        FractalState that = (FractalState) o;
        // Сравниваем все поля, включая саму функцию через equals
        return maxIterations == that.maxIterations &&
               Objects.equals(viewport, that.viewport) &&
               Objects.equals(colorScheme, that.colorScheme) && // Сравнение через equals схемы
               Objects.equals(fractalFunction, that.fractalFunction); // Сравнение через equals функции
    }

    /**
     * Вычисляет хэш-код для этого состояния фрактала.
     * Хэш-код зависит от {@code viewport}, {@code maxIterations}, {@code colorScheme} и {@code fractalFunction}.
     * Реализация должна быть согласована с {@link #equals(Object)}.
     *
     * @return Хэш-код объекта.
     */
    @Override
    public int hashCode() {
        // Включаем все поля, используемые в equals
        return Objects.hash(viewport, maxIterations, colorScheme, fractalFunction);
    }

    /**
     * Возвращает строковое представление состояния фрактала.
     * Полезно для логирования и отладки. Включает основные параметры.
     *
     * @return Строка, описывающая состояние.
     */
    @Override
    public String toString() {
        return "FractalState{" +
               "viewport=" + viewport +
               ", maxIterations=" + maxIterations +
               ", colorScheme=" + (colorScheme != null ? colorScheme.getName() : "null") + // Проверка на null для getName()
               ", fractalFunction=" + (fractalFunction != null ? fractalFunction.getName() : "null") + // Проверка на null для getName()
               '}';
    }

    // --- Статический фабричный метод ---

    /**
     * Создает начальное (дефолтное) состояние фрактала.
     * Использует стандартную область просмотра {@link Viewport#DEFAULT_VIEWPORT},
     * начальное количество итераций (100), стандартную цветовую схему
     * ({@link NonlinearRGBScheme}) и функцию множества Мандельброта
     * ({@link MandelbrotFunction}).
     *
     * @return Новый экземпляр {@link FractalState} с настройками по умолчанию.
     */
    public static FractalState createDefault() {
        return new FractalState(
            Viewport.DEFAULT_VIEWPORT,
            100, // Начальное количество итераций
            new NonlinearRGBScheme(), // Можно выбрать другую схему по умолчанию
            DEFAULT_FRACTAL_FUNCTION // Используем функцию Мандельброта по умолчанию
        );
    }
}

// File: core/src/main/java/model/Keyframe.java

// File: core/src/main/java/model/Keyframe.java
package model;

import java.io.Serializable;
import java.util.Objects;

/**
 * Представляет ключевой кадр для анимации фрактала.
 * Содержит состояние фрактала {@link FractalState} в этот момент
 * и необязательное имя для идентификации в UI.
 * Реализует {@link Serializable} для возможного сохранения/загрузки настроек анимации.
 */
public class Keyframe implements Serializable {
    private static final long serialVersionUID = 1L;

    private final FractalState state;
    private String name; // Имя кадра (может быть изменено пользователем)

    /**
     * Создает ключевой кадр с заданным состоянием и именем по умолчанию.
     * Имя по умолчанию генерируется на основе Viewport и итераций.
     * @param state Состояние фрактала для этого кадра. Не может быть null.
     */
    public Keyframe(FractalState state) {
        this(state, generateDefaultName(state));
    }

    /**
     * Создает ключевой кадр с заданным состоянием и именем.
     * @param state Состояние фрактала для этого кадра. Не может быть null.
     * @param name Имя кадра.
     */
    public Keyframe(FractalState state, String name) {
        this.state = Objects.requireNonNull(state, "Состояние FractalState не может быть null");
        this.name = (name != null && !name.isBlank()) ? name : generateDefaultName(state);
    }

    /**
     * Генерирует имя по умолчанию для кадра на основе его состояния.
     * @param state Состояние кадра.
     * @return Строка с описанием вида.
     */
    private static String generateDefaultName(FractalState state) {
        if (state == null || state.getViewport() == null) {
            return "Invalid State";
        }
        Viewport vp = state.getViewport();
        // Генерируем краткое имя, например, центр и ширина
        double centerX = (vp.getMinX() + vp.getMaxX()) / 2.0;
        double centerY = (vp.getMinY() + vp.getMaxY()) / 2.0;
        return String.format("Center=(%.3g, %.3g), W=%.3g, Iter=%d",
                             centerX, centerY, vp.getWidth(), state.getMaxIterations());
    }

    /**
     * Возвращает состояние фрактала для этого ключевого кадра.
     * @return {@link FractalState}.
     */
    public FractalState getState() {
        return state;
    }

    /**
     * Возвращает имя ключевого кадра.
     * @return Имя кадра.
     */
    public String getName() {
        return name;
    }

    /**
     * Устанавливает новое имя для ключевого кадра.
     * @param name Новое имя. Если null или пустое, имя не меняется.
     */
    public void setName(String name) {
        if (name != null && !name.isBlank()) {
            this.name = name;
        }
    }

    /**
     * Возвращает имя кадра для отображения, например, в JList.
     * Переопределяем toString для удобства.
     * @return Имя кадра.
     */
    @Override
    public String toString() {
        return name;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Keyframe keyframe = (Keyframe) o;
        // Сравниваем по состоянию, имя может быть разным
        return Objects.equals(state, keyframe.state);
    }

    @Override
    public int hashCode() {
        // Хэш-код зависит только от состояния
        return Objects.hash(state);
    }
}

// File: core/src/main/java/model/NonlinearRGBScheme.java

// File: core/src/main/java/model/NonlinearRGBScheme.java
package model;

import java.awt.Color;
import java.io.Serializable; // Импорт добавлен для полноты

/**
 * Пример нелинейной цветовой схемы RGB для визуализации фракталов.
 * Точки, принадлежащие множеству (достигшие максимального числа итераций), окрашиваются в черный цвет.
 * Точки вне множества окрашиваются в цвета, вычисляемые с помощью нелинейных функций
 * от нормализованного количества итераций. Формулы подобраны эмпирически для получения
 * определенного эстетического вида с переходами через синий, зеленый, желтый/оранжевый цвета.
 * Реализует интерфейс {@link ColorScheme} и {@link Serializable}.
 */
public class NonlinearRGBScheme implements ColorScheme {
    /**
     * Версия для сериализации. Важна для совместимости при сохранении/загрузке состояния.
     */
    private static final long serialVersionUID = 1L;

    /**
     * {@inheritDoc}
     * Возвращает цвет пикселя на основе количества итераций.
     * <ul>
     *     <li>Если {@code iterations >= maxIterations} (точка внутри множества) или {@code maxIterations <= 1} (некорректный предел), возвращает {@link Color#BLACK}.</li>
     *     <li>В противном случае, вычисляет RGB компоненты цвета. Используется нормализованное значение итераций
     *         {@code t = (double) iterations / maxIterations} в диапазоне [0, 1).
     *         Компоненты R, G, B вычисляются по нелинейным формулам, зависящим от {@code t},
     *         подобранным для создания плавных цветовых переходов.
     *         Например:
     *         <ul>
     *             <li>R: {@code 9 * (1-t) * t^3 * 255}</li>
     *             <li>G: {@code 15 * (1-t)^2 * t^2 * 255}</li>
     *             <li>B: {@code 8.5 * (1-t)^3 * t * 255}</li>
     *         </ul>
     *         Результаты ограничиваются диапазоном [0, 255].
     *     </li>
     * </ul>
     *
     * @param iterations    Количество итераций, выполненных для точки.
     * @param maxIterations Максимальное количество итераций, заданное для рендеринга.
     * @return Вычисленный цвет {@link Color} или черный.
     */
    @Override
    public Color getColor(int iterations, int maxIterations) {
        // Точка внутри множества или некорректный maxIterations
        if (iterations >= maxIterations || maxIterations <= 1) {
            return Color.BLACK;
        }

        // Нормализуем количество итераций к диапазону [0, 1)
        // t = 0 соответствует 0 итераций, t стремится к 1 при iterations -> maxIterations - 1
        // Используем maxIterations в знаменателе, так как итерации от 0 до maxIterations-1
        double t = (double) iterations / maxIterations;

        // Нелинейные функции для R, G, B.
        // Эти формулы выбраны эмпирически для получения определенного цветового градиента.
        // Можно экспериментировать с другими функциями (степенные, синусоидальные, логарифмические и т.д.).
        // Коэффициенты (9, 15, 8.5) и степени подобраны для управления яркостью и цветом.
        // Использование (1-t) обеспечивает затухание к черному при приближении к maxIterations.
        int r = (int) (9.0 * (1.0 - t) * t * t * t * 255.0);
        int g = (int) (15.0 * (1.0 - t) * (1.0 - t) * t * t * 255.0);
        int b = (int) (8.5 * (1.0 - t) * (1.0 - t) * (1.0 - t) * t * 255.0);

        // Ограничиваем значения диапазоном [0, 255], чтобы избежать выхода за пределы
        // из-за ошибок округления или особенностей формул.
        r = Math.min(255, Math.max(0, r));
        g = Math.min(255, Math.max(0, g));
        b = Math.min(255, Math.max(0, b));

        return new Color(r, g, b);
    }

     /**
     * {@inheritDoc}
     * Возвращает имя этой цветовой схемы для отображения в пользовательском интерфейсе.
     * @return Строка "Nonlinear RGB".
     */
     @Override
     public String getName() {
         return "Nonlinear RGB"; // Название схемы для UI
     }

     /**
      * Сравнивает эту цветовую схему с другим объектом.
      * Две {@code NonlinearRGBScheme} считаются равными, так как у них нет настраиваемых параметров.
      * @param obj Объект для сравнения.
      * @return {@code true}, если {@code obj} является экземпляром {@code NonlinearRGBScheme}, иначе {@code false}.
      */
     @Override
     public boolean equals(Object obj) {
         // Проверка на null и на совпадение класса
         if (this == obj) return true;
         return obj != null && getClass() == obj.getClass();
     }

     /**
      * Возвращает хэш-код для этой цветовой схемы.
      * Так как все экземпляры {@code NonlinearRGBScheme} эквивалентны,
      * хэш-код основан только на классе.
      * @return Хэш-код, соответствующий классу {@code NonlinearRGBScheme}.
      */
     @Override
     public int hashCode() {
         // Хэш-код одинаков для всех экземпляров этого класса.
         return NonlinearRGBScheme.class.hashCode();
     }
}

// File: core/src/main/java/model/Viewport.java

// File: core/src/main/java/model/Viewport.java
package model;

import java.io.Serializable;
import java.util.Objects;

/**
 * Представляет прямоугольную область комплексной плоскости, отображаемую в данный момент.
 * Является неизменяемым (immutable) объектом, определяемым минимальными и максимальными
 * вещественными (X) и мнимыми (Y) координатами.
 * Используется для определения, какая часть фрактала видна, и для преобразования
 * координат между экранными пикселями и комплексными числами.
 * Реализует {@link Serializable} для сохранения/загрузки состояния.
 */
public final class Viewport implements Serializable {
    /**
     * Версия для сериализации. Важна для совместимости.
     */
    private static final long serialVersionUID = 1L;

    /** Минимальная вещественная координата (левая граница). */
    private final double minX;
    /** Максимальная вещественная координата (правая граница). */
    private final double maxX;
    /** Минимальная мнимая координата (нижняя граница). */
    private final double minY;
    /** Максимальная мнимая координата (верхняя граница). */
    private final double maxY;

    /**
     * Область просмотра по умолчанию, охватывающая стандартный вид множества Мандельброта
     * (от -2.0 до 1.0 по вещественной оси, от -1.5 до 1.5 по мнимой).
     */
    public static final Viewport DEFAULT_VIEWPORT = new Viewport(-2.0, 1.0, -1.5, 1.5);

    /**
     * Создает новый экземпляр Viewport.
     * Гарантирует, что {@code minX <= maxX} и {@code minY <= maxY},
     * автоматически упорядочивая переданные значения при необходимости.
     *
     * @param minX Минимальная или максимальная вещественная координата.
     * @param maxX Максимальная или минимальная вещественная координата.
     * @param minY Минимальная или максимальная мнимая координата.
     * @param maxY Максимальная или минимальная мнимая координата.
     */
    public Viewport(double minX, double maxX, double minY, double maxY) {
        // Гарантируем правильный порядок координат min <= max
        this.minX = Math.min(minX, maxX);
        this.maxX = Math.max(minX, maxX);
        this.minY = Math.min(minY, maxY);
        this.maxY = Math.max(minY, maxY);
    }

    // --- Геттеры ---

    /**
     * Возвращает минимальную вещественную координату (левую границу) области просмотра.
     * @return Значение {@code minX}.
     */
    public double getMinX() {
        return minX;
    }

    /**
     * Возвращает максимальную вещественную координату (правую границу) области просмотра.
     * @return Значение {@code maxX}.
     */
    public double getMaxX() {
        return maxX;
    }

    /**
     * Возвращает минимальную мнимую координату (нижнюю границу) области просмотра.
     * @return Значение {@code minY}.
     */
    public double getMinY() {
        return minY;
    }

    /**
     * Возвращает максимальную мнимую координату (верхнюю границу) области просмотра.
     * @return Значение {@code maxY}.
     */
    public double getMaxY() {
        return maxY;
    }

    /**
     * Вычисляет ширину области просмотра ({@code maxX - minX}).
     * @return Ширина области просмотра. Может быть 0.
     */
    public double getWidth() {
        return maxX - minX;
    }

    /**
     * Вычисляет высоту области просмотра ({@code maxY - minY}).
     * @return Высота области просмотра. Может быть 0.
     */
    public double getHeight() {
        return maxY - minY;
    }

    /**
     * Вычисляет соотношение сторон области просмотра (ширина / высота).
     * Важно для сохранения пропорций при масштабировании.
     * @return Соотношение сторон (width / height). Возвращает {@link Double#NaN}, если высота равна нулю.
     */
    public double getAspectRatio() {
         double h = getHeight();
         // Проверка деления на ноль
         return (h == 0.0) ? Double.NaN : getWidth() / h; // Используем 0.0 для сравнения с double
    }

    // --- Методы для изменения Viewport (возвращают новый immutable экземпляр) ---

    /**
     * Создает новый экземпляр {@code Viewport}, представляющий результат масштабирования (приближения)
     * к указанной прямоугольной области комплексной плоскости ({@code newMinX}, {@code newMaxX},
     * {@code newMinY}, {@code newMaxY}).
     * <p>
     * Важной особенностью является корректировка результирующей области для сохранения
     * заданного целевого соотношения сторон ({@code targetAspectRatio}), которое обычно
     * соответствует соотношению сторон панели отрисовки. Это предотвращает искажения изображения.
     * Коррекция выполняется путем расширения более короткой стороны (относительно целевого соотношения)
     * так, чтобы центр исходно запрошенной области остался центром скорректированной области.
     *
     * @param newMinX      Желаемая минимальная вещественная координата новой области (или максимальная).
     * @param newMaxX      Желаемая максимальная вещественная координата новой области (или минимальная).
     * @param newMinY      Желаемая минимальная мнимая координата новой области (или максимальная).
     * @param newMaxY      Желаемая максимальная мнимая координата новой области (или минимальная).
     * @param targetAspectRatio Желаемое соотношение сторон (ширина / высота) результирующего Viewport.
     *                          Должно быть положительным числом.
     * @return Новый экземпляр {@link Viewport}, представляющий масштабированную и скорректированную
     *         область. Если входные параметры некорректны (например, нулевая ширина/высота запрошенной области
     *         или некорректное {@code targetAspectRatio}), может вернуть текущий {@code Viewport} без изменений.
     */
    public Viewport zoom(double newMinX, double newMaxX, double newMinY, double newMaxY, double targetAspectRatio) {
        // Упорядочиваем координаты, чтобы min был меньше max
        double requestedMinX = Math.min(newMinX, newMaxX);
        double requestedMaxX = Math.max(newMinX, newMaxX);
        double requestedMinY = Math.min(newMinY, newMaxY);
        double requestedMaxY = Math.max(newMinY, newMaxY);

        double requestedWidth = requestedMaxX - requestedMinX;
        double requestedHeight = requestedMaxY - requestedMinY;

        // Проверка на вырожденный прямоугольник или некорректное соотношение сторон
        // Используем небольшой допуск EPSILON для сравнения double с нулем
        final double EPSILON = 1e-9;
        if (requestedWidth < EPSILON || requestedHeight < EPSILON || Double.isNaN(targetAspectRatio) || targetAspectRatio < EPSILON) {
            System.err.println("Invalid zoom parameters or aspect ratio. Returning current viewport. "
                             + "Requested W/H: " + requestedWidth + "/" + requestedHeight + ", Target Aspect: " + targetAspectRatio);
            return this; // Невалидный зум или соотношение сторон, возвращаем текущий viewport без изменений
        }

        // Конечные координаты, которые будут скорректированы
        double finalMinX = requestedMinX;
        double finalMaxX = requestedMaxX;
        double finalMinY = requestedMinY;
        double finalMaxY = requestedMaxY;

        // Вычисляем текущее соотношение сторон запрошенной области
        double currentAspectRatio = requestedWidth / requestedHeight;

        // Сравниваем с целевым соотношением сторон (с небольшим допуском для double)
        if (Math.abs(currentAspectRatio - targetAspectRatio) > EPSILON) {
            // Соотношения сторон не совпадают, нужно скорректировать
            if (currentAspectRatio < targetAspectRatio) {
                // Запрошенный прямоугольник "уже" (меньше ширина), чем целевой.
                // Нужно увеличить ширину, сохраняя центр по X.
                double centerX = (requestedMinX + requestedMaxX) / 2.0;
                double requiredWidth = requestedHeight * targetAspectRatio;
                // double widthDiff = requiredWidth - requestedWidth;
                // finalMinX -= widthDiff / 2.0;
                // finalMaxX += widthDiff / 2.0;
                // Альтернативный расчет через центр:
                finalMinX = centerX - requiredWidth / 2.0;
                finalMaxX = centerX + requiredWidth / 2.0;

            } else {
                // Запрошенный прямоугольник "шире" (меньше высота), чем целевой.
                // Нужно увеличить высоту, сохраняя центр по Y.
                double centerY = (requestedMinY + requestedMaxY) / 2.0;
                double requiredHeight = requestedWidth / targetAspectRatio;
                // double heightDiff = requiredHeight - requestedHeight;
                // finalMinY -= heightDiff / 2.0;
                // finalMaxY += heightDiff / 2.0;
                // Альтернативный расчет через центр:
                finalMinY = centerY - requiredHeight / 2.0;
                finalMaxY = centerY + requiredHeight / 2.0;
            }
        }

        // Опционально: можно было бы ограничить новый viewport границами старого,
        // но для свободного зума это обычно не требуется.
        // finalMinX = Math.max(finalMinX, this.minX);
        // finalMaxX = Math.min(finalMaxX, this.maxX);
        // finalMinY = Math.max(finalMinY, this.minY);
        // finalMaxY = Math.min(finalMaxY, this.maxY);

        // Создаем новый неизменяемый экземпляр с вычисленными границами
        return new Viewport(finalMinX, finalMaxX, finalMinY, finalMaxY);
    }


     /**
      * Создает новый экземпляр {@code Viewport} путем панорамирования (сдвига)
      * текущей области просмотра на указанные смещения по осям X и Y
      * в координатах комплексной плоскости.
      *
      * @param deltaX Изменение вещественной координаты (сдвиг вдоль оси X).
      *               Положительное значение сдвигает вправо, отрицательное - влево.
      * @param deltaY Изменение мнимой координаты (сдвиг вдоль оси Y).
      *               Положительное значение сдвигает вверх, отрицательное - вниз.
      * @return Новый экземпляр {@link Viewport}, представляющий сдвинутую область просмотра.
      */
     public Viewport pan(double deltaX, double deltaY) {
         // Просто прибавляем смещения к текущим границам для создания нового Viewport
         return new Viewport(minX + deltaX, maxX + deltaX, minY + deltaY, maxY + deltaY);
     }

    // --- Стандартные методы Object ---

    /**
     * Сравнивает этот {@code Viewport} с другим объектом на равенство.
     * Два {@code Viewport} считаются равными, если их соответствующие координаты
     * ({@code minX}, {@code maxX}, {@code minY}, {@code maxY}) равны.
     * Используется {@link Double#compare(double, double)} для корректного сравнения
     * значений типа double, включая {@code NaN} и {@code +/-Infinity}.
     *
     * @param o Объект для сравнения.
     * @return {@code true}, если объекты равны, иначе {@code false}.
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Viewport viewport = (Viewport) o;
        // Сравнение всех четырех координат
        return Double.compare(viewport.minX, minX) == 0 &&
               Double.compare(viewport.maxX, maxX) == 0 &&
               Double.compare(viewport.minY, minY) == 0 &&
               Double.compare(viewport.maxY, maxY) == 0;
    }

    /**
     * Вычисляет хэш-код для этого {@code Viewport}.
     * Хэш-код зависит от всех четырех координат ({@code minX}, {@code maxX}, {@code minY}, {@code maxY}).
     * Реализация согласована с {@link #equals(Object)}.
     *
     * @return Хэш-код объекта.
     */
    @Override
    public int hashCode() {
        return Objects.hash(minX, maxX, minY, maxY);
    }

    /**
     * Возвращает строковое представление {@code Viewport}.
     * Удобно для логирования и отладки. Включает координаты границ, ширину и высоту.
     * Использует формат {@code %g} для компактного представления чисел double.
     *
     * @return Строковое представление объекта {@code Viewport}.
     */
    @Override
    public String toString() {
        return String.format("Viewport[x=(%g, %g), y=(%g, %g), w=%g, h=%g]",
                             minX, maxX, minY, maxY, getWidth(), getHeight());
    }
}

// File: core/src/main/java/model/ColorScheme.java

// File: core/src/main/java/model/ColorScheme.java
package model;

import java.awt.Color;
import java.io.Serializable;

/**
 * Функциональный интерфейс, определяющий стратегию преобразования
 * количества итераций, полученных при расчете точки фрактала, в цвет.
 * Реализации этого интерфейса позволяют легко менять внешний вид
 * визуализации фрактала.
 * <p>
 * Реализации должны быть {@link Serializable}, чтобы {@link FractalState},
 * содержащий схему, можно было сохранять и загружать.
 * </p>
 * <p>
 * Помечен как {@link FunctionalInterface}, так как содержит единственный
 * абстрактный метод {@link #getColor(int, int)}, хотя наличие
 * метода по умолчанию {@link #getName()} этому не мешает.
 * </p>
 */
@FunctionalInterface
public interface ColorScheme extends Serializable {
    /**
     * Версия для сериализации. Необходимо явно указывать для всех
     * {@link Serializable} классов и интерфейсов для контроля совместимости версий.
     */
    long serialVersionUID = 1L;

    /**
     * Вычисляет и возвращает цвет для точки фрактала на основе
     * количества выполненных итераций и максимального заданного
     * количества итераций для рендеринга.
     * <p>
     * По соглашению, если {@code iterations == maxIterations}, это означает,
     * что точка считается принадлежащей множеству (не "убежала" за предел),
     * и для таких точек обычно возвращается {@link Color#BLACK}.
     * </p>
     *
     * @param iterations    Количество итераций, выполненных до выхода точки за предел
     *                      (или {@code maxIterations}, если точка принадлежит множеству).
     * @param maxIterations Максимальное количество итераций, заданное в настройках
     *                      рендеринга (используется как верхний предел и для нормализации).
     * @return Рассчитанный {@link Color} для данной точки.
     */
    Color getColor(int iterations, int maxIterations);

    /**
     * Возвращает имя цветовой схемы, понятное пользователю.
     * Это имя может использоваться, например, в элементах управления
     * пользовательского интерфейса (меню, списки выбора).
     * <p>
     * Реализация по умолчанию возвращает простое имя класса реализации схемы.
     * Реализации могут переопределить этот метод для предоставления более
     * осмысленного или локализованного имени.
     * </p>
     *
     * @return Строка с именем цветовой схемы.
     */
    default String getName() {
        // Имя по умолчанию - простое имя класса реализации.
        return this.getClass().getSimpleName();
    }

    // Метод equals() и hashCode() не объявляются в интерфейсе,
    // но реализации ДОЛЖНЫ их переопределять, если они имеют состояние,
    // или для корректного сравнения в FractalState.
    // Стандартное поведение equals/hashCode от Object не подходит для Serializable объектов
    // и для логики сравнения состояний.
}

// File: core/src/main/java/math/MandelbrotFunction.java

// File: core/src/main/java/math/MandelbrotFunction.java
package math;

import utils.ComplexNumber;

/**
 * Реализация интерфейса {@link FractalFunction} для расчета итераций
 * классического множества Мандельброта.
 * <p>
 * Множество Мандельброта определяется для точек {@code c} комплексной плоскости.
 * Для каждой точки {@code c} выполняется итерационная формула:
 * {@code z_{n+1} = z_n^2 + c}, начиная с {@code z_0 = 0}.
 * Точка {@code c} считается принадлежащей множеству, если последовательность {@code z_n}
 * остается ограниченной (обычно проверяется условие {@code |z_n|^2 <= 4})
 * в течение заданного максимального числа итераций.
 * </p>
 * <p>
 * Этот класс является неизменяемым и реализует {@link java.io.Serializable}.
 * </p>
 */
public class MandelbrotFunction implements FractalFunction {
    /**
     * Версия для сериализации.
     */
    private static final long serialVersionUID = 1L;

    /**
     * {@inheritDoc}
     * <p>
     * Вычисляет количество итераций для точки {@code c} на комплексной плоскости
     * согласно алгоритму Мандельброта.
     * </p><p>
     * Итерации выполняются по формуле {@code z = z^2 + c}, начиная с {@code z = 0}.
     * Расчет останавливается, если {@code |z|^2 > 4} (точка "убежала") или
     * достигнуто максимальное количество итераций {@code maxIterations}.
     * </p><p>
     * Параметр {@code z0Ignored} из интерфейса {@link FractalFunction#calculateIterations(ComplexNumber, ComplexNumber, int)}
     * в данной реализации **игнорируется**, так как для Мандельброта начальное значение {@code z} всегда равно 0.
     * Параметр {@code c} интерфейса используется как точка комплексной плоскости, для которой производится расчет.
     * </p>
     *
     * @param z0Ignored     Начальное значение z (игнорируется).
     * @param c             Точка комплексной плоскости, для которой вычисляются итерации.
     * @param maxIterations Максимальное число итераций.
     * @return Количество выполненных итераций (от 0 до {@code maxIterations - 1}), если точка "убежала",
     *         или {@code maxIterations}, если точка считается принадлежащей множеству.
     */
    @Override
    public int calculateIterations(ComplexNumber z0Ignored, ComplexNumber c, int maxIterations) {
        // Для Мандельброта z всегда начинается с 0
        ComplexNumber z = new ComplexNumber(0, 0);
        // c - это точка, которую мы проверяем (передана как второй аргумент)

        for (int i = 0; i < maxIterations; ++i) {
            // Проверка выхода за радиус 2 (используем квадрат модуля |z|^2 > 4 для оптимизации)
            if (z.magnitudeSquared() > 4.0) {
                return i; // Точка вне множества, возвращаем число выполненных итераций
            }
            // Итерация: z = z^2 + c
            z = z.square().add(c);
        }
        // Если цикл завершился, значит точка не "убежала" за maxIterations шагов.
        // Считаем ее принадлежащей множеству (или находящейся очень близко к нему).
        return maxIterations;
    }

    /**
     * {@inheritDoc}
     * Возвращает имя функции для отображения.
     * @return Строка "Mandelbrot Set".
     */
    @Override
    public String getName() {
        return "Mandelbrot Set";
    }

     /**
      * Сравнивает эту функцию с другим объектом.
      * Все экземпляры {@code MandelbrotFunction} считаются эквивалентными,
      * так как у них нет изменяемого состояния.
      * @param obj Объект для сравнения.
      * @return {@code true}, если {@code obj} является экземпляром {@code MandelbrotFunction}, иначе {@code false}.
      */
     @Override
     public boolean equals(Object obj) {
         // Проверка на null и на совпадение класса
         if (this == obj) return true;
         return obj != null && getClass() == obj.getClass(); // Все экземпляры эквивалентны
     }

     /**
      * Возвращает хэш-код для этой функции.
      * Так как все экземпляры эквивалентны, хэш-код основан только на классе.
      * @return Хэш-код, соответствующий классу {@code MandelbrotFunction}.
      */
     @Override
     public int hashCode() {
         return MandelbrotFunction.class.hashCode();
     }
}

// File: core/src/main/java/math/JuliaFunction.java

// File: core/src/main/java/math/JuliaFunction.java
package math;

import utils.ComplexNumber;
import java.util.Objects;

/**
 * Реализация интерфейса {@link FractalFunction} для расчета итераций
 * множеств Жюлиа.
 * <p>
 * Множество Жюлиа {@code J(c)} определяется для фиксированного комплексного параметра {@code c}.
 * Принадлежность точки {@code z0} комплексной плоскости множеству Жюлиа {@code J(c)}
 * определяется поведением итерационной формулы:
 * {@code z_{n+1} = z_n^2 + c}, начиная с {@code z_0} (которое равно проверяемой точке).
 * Точка {@code z0} считается принадлежащей множеству {@code J(c)}, если последовательность {@code z_n}
 * остается ограниченной (обычно проверяется условие {@code |z_n|^2 <= Порог}, где порог часто равен 4)
 * в течение заданного максимального числа итераций.
 * </p><p>
 * В отличие от множества Мандельброта, здесь параметр {@code c} является константой для всего множества,
 * а начальное значение {@code z_0} меняется для каждой проверяемой точки.
 * </p><p>
 * Этот класс является неизменяемым и реализует {@link java.io.Serializable}.
 * </p>
 */
public class JuliaFunction implements FractalFunction {
    /**
     * Версия для сериализации.
     */
    private static final long serialVersionUID = 1L;

    /**
     * Константный комплексный параметр 'c', определяющий конкретное множество Жюлиа.
     * Является частью состояния этой функции.
     */
    private final ComplexNumber c;

    /**
     * Создает функцию для расчета множества Жюлиа с заданным параметром {@code c}.
     * @param c Комплексный параметр 'c', определяющий множество. Не может быть null.
     * @throws NullPointerException если {@code c} равно null.
     */
    public JuliaFunction(ComplexNumber c) {
        this.c = Objects.requireNonNull(c, "Параметр 'c' не может быть null");
    }

    /**
     * {@inheritDoc}
     * <p>
     * Вычисляет количество итераций для начальной точки {@code z0} на комплексной плоскости
     * для множества Жюлиа, определяемого константой {@link #c}.
     * </p><p>
     * Итерации выполняются по формуле {@code z = z^2 + this.c}, начиная с {@code z = z0}.
     * Расчет останавливается, если {@code |z|^2 > Порог} (например, 4.0) или
     * достигнуто максимальное количество итераций {@code maxIterations}.
     * </p><p>
     * Параметр {@code z0} из интерфейса {@link FractalFunction#calculateIterations(ComplexNumber, ComplexNumber, int)}
     * используется как начальная точка итераций.
     * Параметр {@code cIgnored} интерфейса **игнорируется**, так как константа {@code c}
     * хранится в поле {@link #c} этого объекта.
     * </p>
     *
     * @param z0            Начальная точка комплексной плоскости, для которой вычисляются итерации.
     * @param cIgnored      Параметр 'c' из интерфейса (игнорируется).
     * @param maxIterations Максимальное число итераций.
     * @return Количество выполненных итераций (от 0 до {@code maxIterations - 1}), если точка "убежала",
     *         или {@code maxIterations}, если точка считается принадлежащей множеству {@code J(c)}.
     */
    @Override
    public int calculateIterations(ComplexNumber z0, ComplexNumber cIgnored, int maxIterations) {
        // z начинается с точки z0 (первый аргумент)
        ComplexNumber z = z0;
        // c - это константа, хранящаяся в поле this.c

        // Порог выхода обычно 4.0 (|z|^2 > 4 => |z| > 2)
        final double escapeRadiusSquared = 4.0;

        for (int i = 0; i < maxIterations; ++i) {
            if (z.magnitudeSquared() > escapeRadiusSquared) {
                return i; // Точка вне множества
            }
            // Итерация: z = z^2 + this.c
            z = z.square().add(this.c);
        }
        // Точка не "убежала" за maxIterations шагов
        return maxIterations;
    }

    /**
     * {@inheritDoc}
     * Возвращает имя функции, включающее значение параметра {@code c}.
     * @return Строка вида "Julia Set (c=...)".
     */
    @Override
    public String getName() {
        // Включаем параметр 'c' в имя для информативности
        return "Julia Set (c=" + c.toString() + ")";
    }

    /**
     * Сравнивает эту функцию Жюлиа с другим объектом.
     * Две {@code JuliaFunction} считаются равными, если у них совпадает
     * константный параметр {@link #c}.
     * Это важно для корректного сравнения {@link FractalState}.
     *
     * @param o Объект для сравнения.
     * @return {@code true}, если {@code o} является {@code JuliaFunction} с тем же параметром {@code c}, иначе {@code false}.
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        JuliaFunction that = (JuliaFunction) o;
        return Objects.equals(c, that.c); // Сравнение по значению параметра 'c'
    }

    /**
     * Возвращает хэш-код для этой функции Жюлиа.
     * Хэш-код зависит от константного параметра {@link #c}.
     * Реализация согласована с {@link #equals(Object)}.
     *
     * @return Хэш-код, основанный на параметре {@code c}.
     */
    @Override
    public int hashCode() {
        return Objects.hash(c); // Хэш-код на основе 'c'
    }
}

// File: core/src/main/java/math/FractalFunction.java

// File: core/src/main/java/math/FractalFunction.java
package math;

import utils.ComplexNumber;
import java.io.Serializable;

/**
 * Функциональный интерфейс, представляющий собой стратегию вычисления
 * количества итераций для точки в некотором фрактальном множестве.
 * <p>
 * Этот интерфейс позволяет абстрагироваться от конкретного типа фрактала
 * (например, Мандельброт, Жюлиа, Пальцы Будды и т.д.), предоставляя единый
 * метод {@link #calculateIterations(ComplexNumber, ComplexNumber, int)} для расчета.
 * </p><p>
 * Реализации этого интерфейса должны быть {@link Serializable}, чтобы
 * {@link model.FractalState}, содержащий функцию, можно было сохранять
 * и загружать.
 * </p>
 */
@FunctionalInterface
public interface FractalFunction extends Serializable {
    /**
     * Версия для сериализации. Необходима для {@link Serializable} интерфейсов.
     */
    long serialVersionUID = 1L;

    /**
     * Вычисляет количество итераций для заданной начальной точки {@code z0}
     * и параметра {@code c} до выхода за некоторый предел или до достижения
     * максимального числа итераций.
     * <p>
     * Семантика параметров {@code z0} и {@code c} зависит от конкретной реализации
     * (конкретного типа фрактала):
     * <ul>
     *     <li>Для множества Мандельброта: {@code z0} обычно игнорируется (всегда 0),
     *         а {@code c} - это точка комплексной плоскости, для которой проверяется принадлежность.</li>
     *     <li>Для множества Жюлиа {@code J(c)}: {@code z0} - это точка комплексной плоскости,
     *         для которой проверяется принадлежность, а {@code c} - константный параметр,
     *         определяющий данное множество (реализация обычно хранит свой {@code c}
     *         и может игнорировать переданный параметр {@code c}).</li>
     * </ul>
     *
     * @param z0            Начальная точка итерации (обычно точка комплексной плоскости для проверки).
     * @param c             Параметр функции (например, точка для Мандельброта или константа для Жюлиа).
     * @param maxIterations Максимальное количество итераций, после которого точка считается
     *                      принадлежащей множеству, если она не вышла за предел.
     * @return Количество выполненных итераций до выхода за предел (обычно от 0 до {@code maxIterations - 1}),
     *         или {@code maxIterations}, если точка считается принадлежащей множеству.
     */
    int calculateIterations(ComplexNumber z0, ComplexNumber c, int maxIterations);

    /**
     * Возвращает имя функции фрактала.
     * Может использоваться для отображения в пользовательском интерфейсе или для отладки.
     * Реализация по умолчанию возвращает простое имя класса реализации.
     *
     * @return Строка с именем функции фрактала.
     */
    default String getName() {
        return this.getClass().getSimpleName();
    }

    // Реализации должны переопределять equals() и hashCode(),
    // особенно если функция имеет состояние (например, параметр 'c' в JuliaFunction),
    // для корректного сравнения FractalState.
}

// File: core/src/main/java/utils/CoordinateConverter.java

// File: core/src/main/java/utils/CoordinateConverter.java
package utils;

import model.Viewport;
import java.awt.geom.Point2D; // Используем Point2D для точности с double

/**
 * Утилитарный класс для преобразования координат между системой пиксельных
 * координат экрана (или панели отрисовки) и системой координат комплексной плоскости.
 * Преобразования выполняются на основе заданной области просмотра {@link Viewport}
 * и размеров области отрисовки (ширина и высота в пикселях).
 * <p>
 * Класс содержит статические методы и не предназначен для инстанцирования.
 * Предполагается, что ось Y экранных координат направлена вниз (0 находится вверху),
 * а ось Y (мнимая ось) комплексной плоскости направлена вверх.
 * </p>
 * <p>
 * Этот класс реализует логику преобразования напрямую. В архитектуре упоминалась
 * возможность интеграции с внешним модулем (JAR), но текущий код содержит
 * собственную реализацию.
 * </p>
 */
public final class CoordinateConverter { // final, т.к. утилитарный класс со статическими методами

    // Приватный конструктор, чтобы предотвратить создание экземпляров утилитарного класса
    private CoordinateConverter() {
        throw new UnsupportedOperationException("Это утилитарный класс, его не нужно инстанциировать");
    }

    /**
     * Преобразует координаты экранного пикселя в соответствующее комплексное число.
     *
     * @param screenX      X-координата пикселя на экране (от 0 до {@code screenWidth - 1}).
     * @param screenY      Y-координата пикселя на экране (от 0 до {@code screenHeight - 1}). В Swing 0 - верхний край.
     * @param screenWidth  Общая ширина области отрисовки (в пикселях). Должна быть > 0.
     * @param screenHeight Общая высота области отрисовки (в пикселях). Должна быть > 0.
     * @param viewport     Текущая область просмотра {@link Viewport}, определяющая отображаемый
     *                     регион комплексной плоскости. Не может быть null.
     * @return Соответствующее {@link ComplexNumber} или {@code null}, если входные данные некорректны
     *         (нулевая или отрицательная ширина/высота, {@code viewport == null}).
     */
    public static ComplexNumber screenToComplex(int screenX, int screenY,
                                                int screenWidth, int screenHeight,
                                                Viewport viewport) {
        // Проверка валидности входных данных
        if (screenWidth <= 0 || screenHeight <= 0 || viewport == null) {
            System.err.printf("Ошибка конвертации screenToComplex: Некорректные входные данные (Ширина=%d, Высота=%d, Viewport=%s)%n",
                              screenWidth, screenHeight, viewport);
            return null;
        }

        // --- Логика преобразования ---
        // 1. Вычисляем относительное положение пикселя на экране в диапазоне [0, 1].
        //    Используем (screenWidth - 1.0) и (screenHeight - 1.0), так как пиксели нумеруются
        //    от 0 до width-1 и от 0 до height-1. Деление на (width-1) дает пропорцию.
        //    Используем double для точности.
        //    proportionX = 0 соответствует левому краю (screenX=0), 1 - правому краю (screenX=width-1).
        //    proportionY = 0 соответствует верхнему краю (screenY=0), 1 - нижнему краю (screenY=height-1).
        double proportionX = (screenWidth == 1) ? 0.5 : (double) screenX / (screenWidth - 1.0);   // Избегаем деления на ноль, если ширина 1
        double proportionY = (screenHeight == 1) ? 0.5 : (double) screenY / (screenHeight - 1.0); // Избегаем деления на ноль, если высота 1

        // 2. Преобразуем относительные экранные координаты в координаты комплексной плоскости.
        //    Вещественная часть (real) линейно отображается из [0, 1] в [minX, maxX].
        //    real = minX + proportionX * (maxX - minX)
        double real = viewport.getMinX() + proportionX * viewport.getWidth();

        //    Мнимая часть (imaginary) линейно отображается из [0, 1] в [maxY, minY].
        //    Обратите внимание на инверсию оси Y: proportionY = 0 (верх экрана) соответствует maxY (верх viewport),
        //    а proportionY = 1 (низ экрана) соответствует minY (низ viewport).
        //    imaginary = maxY - proportionY * (maxY - minY)
        double imaginary = viewport.getMaxY() - proportionY * viewport.getHeight();

        return new ComplexNumber(real, imaginary);
    }

     /**
      * Преобразует комплексное число в координаты экранного пикселя.
      *
      * @param complex      Комплексное число {@link ComplexNumber} для преобразования. Не может быть null.
      * @param screenWidth  Общая ширина области отрисовки (в пикселях). Должна быть > 0.
      * @param screenHeight Общая высота области отрисовки (в пикселях). Должна быть > 0.
      * @param viewport     Текущая область просмотра {@link Viewport}. Не может быть null.
      * @return Объект {@link Point2D.Double}, представляющий экранные координаты (x, y),
      *         соответствующие комплексному числу. Возвращает {@code null}, если входные данные некорректны.
      *         Если {@code Viewport} имеет нулевую ширину или высоту, возвращает координаты центра экрана
      *         {@code (screenWidth / 2.0, screenHeight / 2.0)}.
      *         Возвращается {@code Point2D.Double} для сохранения точности; вызывающий код
      *         при необходимости должен выполнить округление до {@code int}.
      */
     public static Point2D.Double complexToScreen(ComplexNumber complex,
                                                  int screenWidth, int screenHeight,
                                                  Viewport viewport) {
         // Проверка валидности входных данных
         if (screenWidth <= 0 || screenHeight <= 0 || viewport == null || complex == null) {
             System.err.printf("Ошибка конвертации complexToScreen: Некорректные входные данные (Complex=%s, Ширина=%d, Высота=%d, Viewport=%s)%n",
                               complex, screenWidth, screenHeight, viewport);
             return null;
         }

         double viewportWidth = viewport.getWidth();
         double viewportHeight = viewport.getHeight();

         // Проверка на вырожденный Viewport (нулевая ширина или высота)
         // Используем небольшой допуск EPSILON для сравнения double с нулем
         final double EPSILON = 1e-9;
         if (viewportWidth < EPSILON || viewportHeight < EPSILON) {
              System.err.println("Ошибка конвертации complexToScreen: Viewport имеет нулевую ширину или высоту.");
              // Не можем корректно преобразовать. Вернем центр экрана как запасной вариант.
              return new Point2D.Double(screenWidth / 2.0, screenHeight / 2.0);
              // Альтернативно: можно вернуть null или бросить исключение
              // return null;
              // throw new IllegalArgumentException("Viewport has zero width or height");
         }

         // --- Логика преобразования ---
         // 1. Вычисляем относительное положение комплексного числа внутри Viewport в диапазоне [0, 1].
         //    proportionX = (real - minX) / (maxX - minX)
         //    proportionY = (imaginary - minY) / (maxY - minY) -- это для стандартной оси Y
         //    Из-за инверсии оси Y экрана, нам нужно отображение из [maxY, minY] в [0, 1].
         //    proportionY_inverted = (maxY - imaginary) / (maxY - minY)
         double proportionX = (complex.getReal() - viewport.getMinX()) / viewportWidth;
         double proportionY = (viewport.getMaxY() - complex.getImaginary()) / viewportHeight; // Инверсия Y

         // 2. Преобразуем относительные координаты Viewport в абсолютные экранные координаты.
         //    Умножаем на (screenWidth - 1.0) и (screenHeight - 1.0) для получения пиксельных координат [0, width-1] / [0, height-1].
         double screenX = proportionX * (screenWidth - 1.0);
         double screenY = proportionY * (screenHeight - 1.0);

         // Опционально: можно ограничить координаты границами экрана, если complex выходит за пределы viewport
         // screenX = Math.max(0, Math.min(screenWidth - 1, screenX));
         // screenY = Math.max(0, Math.min(screenHeight - 1, screenY));

         return new Point2D.Double(screenX, screenY);
    }
}

// File: core/src/main/java/utils/ComplexNumber.java

// File: core/src/main/java/utils/ComplexNumber.java
package utils;

import java.io.Serializable;
import java.util.Objects;

/**
 * Представляет комплексное число вида {@code z = real + i * imaginary}.
 * Является неизменяемым (immutable) классом: все арифметические операции
 * возвращают новый экземпляр {@code ComplexNumber}, не изменяя текущий.
 * <p>
 * Реализует {@link Serializable} для возможности сохранения в составе {@link model.FractalState}.
 * </p>
 */
public final class ComplexNumber implements Serializable {
    /**
     * Версия для сериализации.
     */
    private static final long serialVersionUID = 1L;

    /** Вещественная часть комплексного числа (Re(z)). */
    private final double real;
    /** Мнимая часть комплексного числа (Im(z)). */
    private final double imaginary;

    /**
     * Константа, представляющая комплексное число 0 (0 + 0i).
     * Может быть полезна в некоторых вычислениях (например, начальное z для Мандельброта).
     */
    public static final ComplexNumber ZERO = new ComplexNumber(0.0, 0.0);


    /**
     * Создает новый экземпляр комплексного числа с заданными вещественной и мнимой частями.
     *
     * @param real      Вещественная часть.
     * @param imaginary Мнимая часть.
     */
    public ComplexNumber(double real, double imaginary) {
        this.real = real;
        this.imaginary = imaginary;
    }

    // --- Геттеры ---

    /**
     * Возвращает вещественную часть комплексного числа.
     * @return Значение поля {@code real}.
     */
    public double getReal() {
        return real;
    }

    /**
     * Возвращает мнимую часть комплексного числа.
     * @return Значение поля {@code imaginary}.
     */
    public double getImaginary() {
        return imaginary;
    }

    // --- Арифметические операции (возвращают новый экземпляр) ---

    /**
     * Вычисляет квадрат модуля (абсолютного значения) комплексного числа:
     * {@code |z|^2 = real^2 + imaginary^2}.
     * <p>
     * Этот метод часто используется вместо вычисления самого модуля {@code sqrt(magnitudeSquared())}
     * в итеративных алгоритмах (как расчет фракталов) для оптимизации,
     * так как операция извлечения квадратного корня является относительно дорогой.
     * Сравнение квадрата модуля с квадратом радиуса (например, {@code |z|^2 > 4})
     * эквивалентно сравнению модуля с радиусом ({@code |z| > 2}).
     * </p>
     *
     * @return Квадрат модуля комплексного числа.
     */
    public double magnitudeSquared() {
        return real * real + imaginary * imaginary;
    }

    /**
     * Вычисляет модуль (абсолютное значение) комплексного числа:
     * {@code |z| = sqrt(real^2 + imaginary^2)}.
     * @return Модуль комплексного числа.
     * @see #magnitudeSquared()
     */
    public double magnitude() {
        return Math.sqrt(magnitudeSquared());
    }


    /**
     * Складывает это комплексное число с другим комплексным числом.
     * Выполняет операцию {@code (this + other)}.
     *
     * @param other Комплексное число для сложения. Не должно быть null.
     * @return Новый экземпляр {@link ComplexNumber}, представляющий сумму {@code (this.real + other.real) + i * (this.imaginary + other.imaginary)}.
     * @throws NullPointerException если {@code other} равно null.
     */
    public ComplexNumber add(ComplexNumber other) {
        Objects.requireNonNull(other, "Other complex number cannot be null for addition");
        return new ComplexNumber(this.real + other.real, this.imaginary + other.imaginary);
    }

    /**
     * Умножает это комплексное число на другое комплексное число.
     * Выполняет операцию {@code (this * other)}.
     * Формула умножения: {@code (a + bi) * (c + di) = (ac - bd) + i * (ad + bc)}.
     *
     * @param other Комплексное число для умножения. Не должно быть null.
     * @return Новый экземпляр {@link ComplexNumber}, представляющий произведение.
     * @throws NullPointerException если {@code other} равно null.
     */
    public ComplexNumber multiply(ComplexNumber other) {
        Objects.requireNonNull(other, "Other complex number cannot be null for multiplication");
        double resultReal = this.real * other.real - this.imaginary * other.imaginary;
        double resultImaginary = this.real * other.imaginary + this.imaginary * other.real;
        return new ComplexNumber(resultReal, resultImaginary);
    }

    /**
     * Возводит это комплексное число в квадрат.
     * Выполняет операцию {@code (this * this)}.
     * Является более эффективной версией вызова {@code this.multiply(this)}.
     * Формула возведения в квадрат: {@code (a + bi)^2 = (a^2 - b^2) + i * (2ab)}.
     *
     * @return Новый экземпляр {@link ComplexNumber}, представляющий квадрат исходного числа.
     */
    public ComplexNumber square() {
        double resultReal = real * real - imaginary * imaginary;
        double resultImaginary = 2 * real * imaginary;
        return new ComplexNumber(resultReal, resultImaginary);
    }

    // --- Стандартные методы Object ---

    /**
     * Сравнивает это комплексное число с другим объектом на равенство.
     * Два комплексных числа считаются равными, если равны их вещественные
     * и мнимые части соответственно.
     * Использует {@link Double#compare(double, double)} для корректного сравнения
     * значений типа double, включая {@code NaN} и {@code +/-Infinity}.
     *
     * @param o Объект для сравнения.
     * @return {@code true}, если {@code o} является {@code ComplexNumber} с теми же
     *         вещественной и мнимой частями, иначе {@code false}.
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ComplexNumber that = (ComplexNumber) o;
        // Сравнение double через Double.compare для корректной обработки NaN и т.п.
        return Double.compare(that.real, real) == 0 &&
               Double.compare(that.imaginary, imaginary) == 0;
    }

    /**
     * Вычисляет хэш-код для этого комплексного числа.
     * Хэш-код зависит от вещественной и мнимой частей.
     * Реализация согласована с {@link #equals(Object)}.
     *
     * @return Хэш-код объекта.
     */
    @Override
    public int hashCode() {
        // Используем стандартный Objects.hash для генерации хэш-кода на основе полей
        return Objects.hash(real, imaginary);
    }

    /**
     * Возвращает строковое представление комплексного числа.
     * Формат: "(real ± |imaginary|i)". Использует {@code %g} для компактного
     * представления чисел double и показывает знак мнимой части.
     * Примеры: "(1.0 + 2.5i)", "(0.0 - 1.0i)", "(3.14 + 0i)".
     *
     * @return Строковое представление комплексного числа.
     */
    @Override
    public String toString() {
        // Форматируем для читаемого вывода
        if (imaginary == 0.0) {
            return String.format("(%g)", real); // Только вещественная часть
        } else if (real == 0.0) {
             return String.format("(%gi)", imaginary); // Только мнимая часть
        } else {
            return String.format("(%g %s %gi)", real, (imaginary >= 0 ? "+" : "-"), Math.abs(imaginary));
        }
    }
}

// File: core/src/main/java/viewmodel/FractalViewModel.java

// File: core/src/main/java/viewmodel/FractalViewModel.java
package viewmodel;

import model.ColorScheme;
import model.FractalState;
import model.Viewport; // Для констант и использования в методах
import render.FractalRenderer;
import viewmodel.commands.Command;
import viewmodel.commands.PanCommand;
import viewmodel.commands.UndoManager;
import viewmodel.commands.ZoomCommand;
import utils.CoordinateConverter;
import utils.ComplexNumber;

import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.util.Objects;

/**
 * ViewModel (согласно паттерну MVVM) для управления состоянием и логикой
 * визуализации фрактала.
 * <p>
 * Обязанности:
 * <ul>
 *     <li>Хранит текущее состояние фрактала ({@link FractalState}).</li>
 *     <li>Предоставляет методы для изменения состояния (зум, панорамирование, смена схемы, итераций),
 *         используя паттерн Команда ({@link Command}) для поддержки отмены действий (Undo).</li>
 *     <li>Управляет историей команд через {@link UndoManager}.</li>
 *     <li>Уведомляет подписчиков (обычно View) об изменениях состояния через {@link PropertyChangeSupport}.</li>
 *     <li>Взаимодействует с {@link CoordinateConverter} для преобразования экранных координат в комплексные.</li>
 * </ul>
 * </p><p>
 * Не занимается непосредственно рендерингом (это задача {@link FractalRenderer}, который обычно
 * вызывается из View компонента {@link view.FractalPanel} при получении уведомления об изменении состояния).
 * </p>
 */
public class FractalViewModel {

    /**
     * Имя свойства для события изменения состояния фрактала ({@link FractalState}).
     * Слушатели могут отслеживать это свойство для обновления отображения.
     * Значение события: {@code (oldState, newState)}.
     */
    public static final String PROPERTY_STATE = "fractalState";
    /**
     * Имя свойства для события изменения возможности отмены последнего действия.
     * Используется для включения/выключения элементов UI (например, пункта меню "Undo").
     * Значение события: {@code (oldCanUndo, newCanUndo)} (тип Boolean).
     */
    public static final String PROPERTY_CAN_UNDO = "canUndo";

    /** Текущее неизменяемое состояние фрактала. */
    private FractalState currentState;
    /** Механизм поддержки слушателей PropertyChange для уведомления View. */
    private final PropertyChangeSupport support = new PropertyChangeSupport(this);
    /** Менеджер для хранения истории команд и выполнения отмены (Undo). */
    private final UndoManager undoManager; // = new UndoManager(100); Инициализируется в конструкторе
    /** Ссылка на рендерер (может не использоваться напрямую, но передается по архитектуре). */
    private final FractalRenderer renderer; // Renderer теперь не используется напрямую для вызова render

    /** Базовое количество итераций для расчета при зуме. */
    private static final int BASE_ITERATIONS_FOR_ZOOM = 50; // Было MIN_ITERATIONS
    /** Коэффициент, определяющий, насколько быстро растут итерации при зуме. */
    private static final double ITERATION_ZOOM_SENSITIVITY = 40.0; // Было ITERATION_ZOOM_FACTOR


    /**
     * Создает ViewModel с начальным состоянием фрактала по умолчанию
     * и заданным максимальным размером истории отмены.
     *
     * @param renderer Экземпляр {@link FractalRenderer}. Хотя ViewModel может не вызывать его методы
     *                 напрямую, он передается для соответствия архитектуре и потенциального использования.
     *                 Не может быть null.
     * @param undoHistorySize Максимальное количество шагов для отмены. Должно быть > 0.
     * @throws NullPointerException если {@code renderer} равен null.
     * @throws IllegalArgumentException если {@code undoHistorySize <= 0}.
     */
    public FractalViewModel(FractalRenderer renderer, int undoHistorySize) {
        this.renderer = Objects.requireNonNull(renderer, "Renderer не может быть null");
        if (undoHistorySize <= 0) {
             throw new IllegalArgumentException("Размер истории Undo должен быть положительным.");
        }
        this.undoManager = new UndoManager(undoHistorySize);
        // Используем статический фабричный метод для создания состояния Мандельброта по умолчанию
        this.currentState = FractalState.createDefault();
        // Уведомление о начальном состоянии не требуется здесь,
        // View (FractalPanel) запросит рендер при первом отображении/изменении размера.
    }

    /**
     * Альтернативный конструктор с размером истории отмены по умолчанию (100 шагов).
     * @param renderer Экземпляр {@link FractalRenderer}. Не может быть null.
     */
     public FractalViewModel(FractalRenderer renderer) {
         this(renderer, 100); // Используем значение по умолчанию 100
     }


    /**
     * Возвращает текущее состояние фрактала.
     *
     * @return Неизменяемый объект {@link FractalState}, представляющий текущий вид.
     */
    public FractalState getCurrentState() {
        return currentState;
    }

    /**
     * Возвращает менеджер отмены {@link UndoManager}.
     * Может использоваться View для проверки возможности отмены ({@code undoManager.canUndo()})
     * или для тестирования.
     *
     * @return Экземпляр {@link UndoManager}.
     */
    public UndoManager getUndoManager() {
        return undoManager;
    }

    /**
     * Загружает новое состояние фрактала ({@code newState}).
     * Обычно используется при загрузке состояния из файла.
     * <p>
     * При загрузке нового состояния происходит следующее:
     * <ul>
     *     <li>Текущее состояние заменяется на {@code newState}.</li>
     *     <li>История отмены (Undo) полностью очищается.</li>
     *     <li>Генерируются события {@link #PROPERTY_STATE} и {@link #PROPERTY_CAN_UNDO}
     *         для уведомления подписчиков (View).</li>
     * </ul>
     *
     * @param newState Новое состояние {@link FractalState} для установки. Не может быть null.
     * @throws NullPointerException если {@code newState} равно null.
     */
    public void loadState(FractalState newState) {
        Objects.requireNonNull(newState, "Новое состояние не может быть null");
        FractalState oldState = this.currentState;
        boolean oldCanUndo = undoManager.canUndo();

        // Проверяем, действительно ли состояние отличается (избегаем лишних действий)
        if (!Objects.equals(oldState, newState)) {
            this.currentState = newState; // Прямое обновление состояния
            undoManager.clearHistory(); // Очистка истории для загруженного состояния

            support.firePropertyChange(PROPERTY_STATE, oldState, this.currentState);
            // После очистки истории canUndo точно станет false
            boolean newCanUndo = false; // undoManager.canUndo() вернет false
            if (oldCanUndo != newCanUndo) { // Уведомляем, только если изменилось
                 support.firePropertyChange(PROPERTY_CAN_UNDO, oldCanUndo, newCanUndo);
            }
            System.out.println("Состояние загружено: " + newState);
            // Рендер запустит панель при получении события PROPERTY_STATE
        } else {
             System.out.println("Загрузка состояния пропущена: новое состояние идентично текущему.");
        }
    }

    /**
     * Выполняет переданную команду {@link Command}.
     * <p>
     * Процесс выполнения:
     * <ul>
     *     <li>Вызывается метод {@code command.execute()}.</li>
     *     <li>Если {@code execute()} вернул {@code true} (команда успешно выполнена и изменила состояние):
     *         <ul>
     *             <li>Команда добавляется в историю {@link UndoManager}.</li>
     *             <li>Генерируются события {@link #PROPERTY_STATE} (с oldState и обновленным currentState)
     *                 и {@link #PROPERTY_CAN_UNDO} (если доступность отмены изменилась)
     *                 для уведомления View.</li>
     *         </ul>
     *     </li>
     *     <li>Если {@code execute()} вернул {@code false}, никаких изменений и уведомлений не происходит.</li>
     * </ul>
     * @param command Команда для выполнения. Не должна быть null.
     */
    private void executeCommand(Command command) {
        Objects.requireNonNull(command, "Команда не может быть null");
        FractalState oldState = this.currentState;
        boolean oldCanUndo = undoManager.canUndo();

        // Команда сама обновит состояние через viewModel.updateStateFromCommand() внутри execute()
        if (command.execute()) {
            // Состояние УЖЕ обновлено командой, теперь нужно добавить в историю и оповестить
            undoManager.addCommand(command);

            // Сравниваем состояния ДО и ПОСЛЕ выполнения команды
            // Если команда ничего не изменила, событие не генерируем
            if (!Objects.equals(oldState, this.currentState)) {
                 support.firePropertyChange(PROPERTY_STATE, oldState, this.currentState);
            } else {
                // Если состояние не изменилось, но команда сказала "true" - странная ситуация
                System.err.println("Предупреждение: Команда " + command.getClass().getSimpleName()
                                   + " вернула true, но состояние ViewModel не изменилось.");
                // Возможно, команду все равно стоит добавить в историю, если она что-то сделала, но не состояние?
                // Пока оставляем как есть - добавляем в историю, но не шлем PROPERTY_STATE.
            }


            boolean newCanUndo = undoManager.canUndo();
            if (oldCanUndo != newCanUndo) { // Уведомляем, только если изменилось
                support.firePropertyChange(PROPERTY_CAN_UNDO, oldCanUndo, newCanUndo);
            }
            // Рендер запустит панель при получении события PROPERTY_STATE (если оно было сгенерировано)
        }
    }

    /**
     * Выполняет масштабирование (зум) в прямоугольную область,
     * заданную координатами углов на экране (в пикселях).
     * Создает и выполняет {@link ZoomCommand}.
     *
     * @param startX      X-координата одного угла выделения (пиксель).
     * @param startY      Y-координата одного угла выделения (пиксель).
     * @param endX        X-координата противоположного угла выделения (пиксель).
     * @param endY        Y-координата противоположного угла выделения (пиксель).
     * @param panelWidth  Текущая ширина панели отрисовки (для конвертации координат и аспекта). Должна быть > 0.
     * @param panelHeight Текущая высота панели отрисовки (для конвертации координат и аспекта). Должна быть > 0.
     */
    public void zoomOnScreenRect(int startX, int startY, int endX, int endY, int panelWidth, int panelHeight) {
        if (panelWidth <= 0 || panelHeight <= 0) {
            System.err.println("zoomOnScreenRect вызван с некорректными размерами панели.");
            return;
        }

        // Конвертируем экранные координаты углов в комплексные числа
        ComplexNumber c1 = CoordinateConverter.screenToComplex(startX, startY, panelWidth, panelHeight, currentState.getViewport());
        ComplexNumber c2 = CoordinateConverter.screenToComplex(endX, endY, panelWidth, panelHeight, currentState.getViewport());

        if (c1 == null || c2 == null) {
            System.err.println("Не удалось сконвертировать экранные координаты для зума.");
            return; // Ошибка конвертации
        }

        // Вычисляем целевое соотношение сторон на основе размеров панели
        double targetAspectRatio = (double) panelWidth / panelHeight;

        // Создаем команду зума, передавая ViewModel, комплексные координаты углов и аспект
        Command zoomCommand = new ZoomCommand(this,
                                              c1.getReal(), c2.getReal(),
                                              c1.getImaginary(), c2.getImaginary(),
                                              targetAspectRatio,
                                              BASE_ITERATIONS_FOR_ZOOM,
                                              ITERATION_ZOOM_SENSITIVITY);
        executeCommand(zoomCommand);
    }

    /**
     * Выполняет панорамирование (сдвиг) вида на заданное смещение в экранных координатах (пикселях).
     * Создает и выполняет {@link PanCommand}.
     *
     * @param deltaX      Смещение по оси X в пикселях. Положительное значение - сдвиг содержимого влево (вид смещается вправо).
     * @param deltaY      Смещение по оси Y в пикселях. Положительное значение - сдвиг содержимого вверх (вид смещается вниз).
     * @param panelWidth  Текущая ширина панели отрисовки (для расчета шага). Должна быть > 0.
     * @param panelHeight Текущая высота панели отрисовки (для расчета шага). Должна быть > 0.
     */
    public void panOnScreenDelta(int deltaX, int deltaY, int panelWidth, int panelHeight) {
        if (panelWidth <= 0 || panelHeight <= 0) {
             System.err.println("panOnScreenDelta вызван с некорректными размерами панели.");
             return;
        }
        if (deltaX == 0 && deltaY == 0) {
            return; // Нет смещения
        }

        // Рассчитываем, какому изменению комплексных координат соответствует сдвиг на один пиксель
        double complexDeltaPerPixelX = currentState.getViewport().getWidth() / (panelWidth > 1 ? (panelWidth - 1.0) : 1.0);
        double complexDeltaPerPixelY = currentState.getViewport().getHeight() / (panelHeight > 1 ? (panelHeight - 1.0) : 1.0);

        // Вычисляем общее смещение в комплексных координатах
        // Знак (-) для deltaX, так как движение мыши вправо (увеличение screenX) должно сдвигать viewport влево (уменьшать minX/maxX)
        // Знак (+) для deltaY, так как движение мыши вниз (увеличение screenY) должно сдвигать viewport вверх (увеличивать minY/maxY) из-за инверсии оси Y экрана.
        double complexDeltaX = -deltaX * complexDeltaPerPixelX;
        double complexDeltaY = deltaY * complexDeltaPerPixelY;

        // Создаем и выполняем команду панорамирования
        Command panCommand = new PanCommand(this, complexDeltaX, complexDeltaY);
        executeCommand(panCommand);
    }

    /**
     * Отменяет последнее выполненное действие (команду).
     * Извлекает последнюю команду из {@link UndoManager} и вызывает ее метод {@code undo()}.
     * Если отмена прошла успешно, генерируются события {@link #PROPERTY_STATE} и
     * {@link #PROPERTY_CAN_UNDO} для уведомления View.
     */
    public void undoLastAction() {
        FractalState oldState = this.currentState;
        boolean oldCanUndo = undoManager.canUndo();

        // undo() внутри себя вызовет viewModel.updateStateFromCommand() через команду
        if (undoManager.undo()) {
             // Состояние УЖЕ обновлено через undo(), оповещаем слушателей
             if (!Objects.equals(oldState, this.currentState)) { // Уведомляем только если состояние изменилось
                 support.firePropertyChange(PROPERTY_STATE, oldState, this.currentState);
             } else {
                 System.err.println("Предупреждение: UndoManager.undo() вернул true, но состояние ViewModel не изменилось.");
             }

             boolean newCanUndo = undoManager.canUndo();
             if (oldCanUndo != newCanUndo) { // Уведомляем, только если изменилось
                 support.firePropertyChange(PROPERTY_CAN_UNDO, oldCanUndo, newCanUndo);
             }
             // Рендер запустит панель при получении события PROPERTY_STATE (если оно было)
        }
    }


    /**
     * Изменяет текущую цветовую схему {@link ColorScheme}.
     * Это действие *не* добавляется в историю отмены (Undo) для простоты.
     * Если бы требовалась отмена смены схемы, это следовало бы реализовать
     * через отдельную команду {@code ChangeColorSchemeCommand}.
     * <p>
     * Если новая схема отличается от текущей, состояние обновляется и
     * генерируется событие {@link #PROPERTY_STATE}.
     * </p>
     *
     * @param newScheme Новая цветовая схема для применения. Не может быть null.
     * @throws NullPointerException если {@code newScheme} равно null.
     */
    public void changeColorScheme(ColorScheme newScheme) {
        Objects.requireNonNull(newScheme, "Цветовая схема не может быть null");
        FractalState oldState = this.currentState;

        // Сравниваем схемы через equals, чтобы избежать обновления, если схема та же
        if (!Objects.equals(oldState.getColorScheme(), newScheme)) {
            // Используем with-метод для создания нового immutable состояния
            FractalState newState = oldState.withColorScheme(newScheme);
            // Напрямую обновляем состояние (без Undo)
            this.currentState = newState;
            support.firePropertyChange(PROPERTY_STATE, oldState, this.currentState);
            System.out.println("Цветовая схема изменена на: " + newScheme.getName());
             // Рендер запустит панель при получении события PROPERTY_STATE
        } else {
             System.out.println("Смена цветовой схемы пропущена: новая схема идентична текущей.");
        }
    }


    /**
     * Изменяет максимальное количество итераций для расчета фрактала.
     * Это действие *не* добавляется в историю отмены (Undo) для простоты.
     * Как и смена схемы, могло бы быть реализовано через команду.
     * <p>
     * Если новое количество итераций отличается от текущего и положительно,
     * состояние обновляется и генерируется событие {@link #PROPERTY_STATE}.
     * </p>
     *
     * @param newMaxIterations Новое максимальное количество итераций. Должно быть > 0.
     */
    public void changeMaxIterations(int newMaxIterations) {
        if (newMaxIterations <= 0) {
            System.err.println("Максимальное количество итераций должно быть положительным.");
            // Можно бросить исключение или показать диалог ошибки во View
            // throw new IllegalArgumentException("Max iterations must be positive.");
            return;
        }
        FractalState oldState = this.currentState;
        if (oldState.getMaxIterations() != newMaxIterations) {
             // Используем with-метод для создания нового immutable состояния
            FractalState newState = oldState.withMaxIterations(newMaxIterations);
            // Напрямую обновляем состояние (без Undo)
            this.currentState = newState;
            support.firePropertyChange(PROPERTY_STATE, oldState, this.currentState);
            System.out.println("Макс. итераций изменено на: " + newMaxIterations);
             // Рендер запустит панель при получении события PROPERTY_STATE
        } else {
             System.out.println("Смена макс. итераций пропущена: новое значение идентично текущему.");
        }
    }


    /**
     * Добавляет слушателя для отслеживания изменений свойств ViewModel
     * ({@link #PROPERTY_STATE} и {@link #PROPERTY_CAN_UNDO}).
     *
     * @param listener Слушатель {@link PropertyChangeListener} для добавления.
     */
    public void addPropertyChangeListener(PropertyChangeListener listener) {
        support.addPropertyChangeListener(listener);
    }

    /**
     * Удаляет ранее добавленного слушателя изменений свойств.
     *
     * @param listener Слушатель {@link PropertyChangeListener} для удаления.
     */
    public void removePropertyChangeListener(PropertyChangeListener listener) {
        support.removePropertyChangeListener(listener);
    }

    /**
     * Внутренний метод для обновления текущего состояния {@link #currentState}.
     * Используется командами ({@link Command#execute()}, {@link Command#undo()})
     * для установки нового или восстановленного состояния.
     * <p>
     * <strong>Важно:</strong> Этот метод сам по себе *не* генерирует события
     * {@code PropertyChange}. Генерация событий происходит в методах
     * {@link #executeCommand(Command)}, {@link #undoLastAction()}, {@link #loadState(FractalState)}
     * после успешного изменения состояния.
     * </p>
     *
     * @param newState Новое состояние {@link FractalState} для установки. Не должно быть null.
     */
    public void updateStateFromCommand(FractalState newState) {
        Objects.requireNonNull(newState, "Новое состояние от команды не может быть null");
        this.currentState = newState;
        // PropertyChange event НЕ генерируется здесь, а в вызывающем методе (executeCommand/undoLastAction)
    }
}

// File: core/src/main/java/viewmodel/commands/PanCommand.java

// File: core/src/main/java/viewmodel/commands/PanCommand.java
package viewmodel.commands;

import model.FractalState;
import model.Viewport;
import viewmodel.FractalViewModel;
import java.util.Objects;

/**
 * Реализация интерфейса {@link Command}, отвечающая за операцию
 * панорамирования (сдвига) области просмотра фрактала ({@link Viewport}).
 * <p>
 * При выполнении ({@link #execute()}) команда вычисляет новый {@code Viewport},
 * сдвинутый на заданные {@code deltaX} и {@code deltaY} относительно текущего,
 * и обновляет состояние в {@link FractalViewModel}.
 * </p><p>
 * При отмене ({@link #undo()}) команда вычисляет предыдущий {@code Viewport},
 * применяя обратный сдвиг ({@code -deltaX}, {@code -deltaY}) к текущему,
 * и восстанавливает это состояние в {@link FractalViewModel}.
 * </p>
 */
public class PanCommand implements Command {

    /** Ссылка на ViewModel для доступа к текущему состоянию и его обновления. */
    private final FractalViewModel viewModel;
    /** Величина сдвига по оси X (вещественной оси) в координатах комплексной плоскости. */
    private final double deltaX;
    /** Величина сдвига по оси Y (мнимой оси) в координатах комплексной плоскости. */
    private final double deltaY;

    /** Флаг, указывающий, была ли команда уже выполнена хотя бы один раз. Используется для логики undo. */
    private boolean executed = false;
    // Сохранять предыдущее состояние (previousViewport) здесь не нужно,
    // так как undo() вычисляет его обратным сдвигом от *текущего на момент undo* состояния.

    /**
     * Создает команду панорамирования.
     *
     * @param viewModel ViewModel, состояние которой будет изменяться. Не может быть null.
     * @param deltaX    Сдвиг по оси X (вещественной) в комплексных координатах.
     * @param deltaY    Сдвиг по оси Y (мнимой) в комплексных координатах.
     * @throws NullPointerException если {@code viewModel} равен null.
     */
    public PanCommand(FractalViewModel viewModel, double deltaX, double deltaY) {
        this.viewModel = Objects.requireNonNull(viewModel, "ViewModel не может быть null");
        this.deltaX = deltaX;
        this.deltaY = deltaY;
    }

    /**
     * Выполняет команду панорамирования.
     * <p>
     * Получает текущее состояние из {@link #viewModel}, вычисляет новый {@link Viewport},
     * сдвинутый на {@link #deltaX} и {@link #deltaY} с помощью метода {@link Viewport#pan(double, double)}.
     * Затем создает новый {@link FractalState} с этим {@code Viewport} и обновляет
     * состояние в {@code viewModel} через {@link FractalViewModel#updateStateFromCommand(FractalState)}.
     * </p>
     *
     * @return {@code true}, если панорамирование было выполнено успешно (т.е. команда еще не была выполнена
     *         после создания или последней отмены, и сдвиг был ненулевым, что привело к изменению Viewport),
     *         {@code false} в противном случае (например, повторное выполнение без отмены, нулевой сдвиг).
     */
    @Override
    public boolean execute() {
         // Команду можно выполнить только один раз между отменами
         if (executed) {
             System.err.println("PanCommand: Попытка повторного выполнения команды без предварительной отмены.");
             return false;
         }
         // Проверяем, есть ли смысл выполнять сдвиг
         if (deltaX == 0.0 && deltaY == 0.0) {
             System.out.println("PanCommand: Нулевой сдвиг, выполнение пропущено.");
             // Не помечаем как executed, так как ничего не сделано
             return false;
         }


         FractalState currentState = viewModel.getCurrentState();
         Viewport currentViewport = currentState.getViewport();

         // Вычисляем новый viewport путем сдвига текущего
         Viewport newViewport = currentViewport.pan(deltaX, deltaY);

         // Хотя проверка на нулевой сдвиг была выше, убедимся, что viewport реально изменился
         // (на случай крайне малых delta или особенностей реализации Viewport.pan/equals)
         if (Objects.equals(newViewport, currentViewport)) {
              System.out.println("PanCommand: Сдвиг не изменил Viewport (возможно, из-за точности double).");
              // Не помечаем как executed, так как состояние не изменилось
              return false;
         }

         // Создаем новое состояние с обновленным viewport
         FractalState nextState = currentState.withViewport(newViewport);
         // Обновляем состояние в ViewModel. ViewModel сам позаботится об уведомлениях позже.
         viewModel.updateStateFromCommand(nextState);
         executed = true; // Помечаем команду как выполненную
         System.out.println("PanCommand: Выполнено. Новый viewport: " + newViewport);
         return true;
    }

    /**
     * Отменяет действие команды панорамирования.
     * <p>
     * Получает текущее состояние из {@link #viewModel}, вычисляет предыдущий {@link Viewport},
     * применяя обратный сдвиг ({@code -deltaX}, {@code -deltaY}) к *текущему* {@code Viewport}
     * с помощью {@link Viewport#pan(double, double)}.
     * Затем создает новый {@link FractalState} с восстановленным {@code Viewport} и обновляет
     * состояние в {@code viewModel} через {@link FractalViewModel#updateStateFromCommand(FractalState)}.
     * </p>
     *
     * @return {@code true}, если отмена была выполнена успешно (т.е. команда была ранее выполнена),
     *         {@code false} в противном случае (попытка отменить невыполненную команду).
     */
    @Override
    public boolean undo() {
         // Отменить можно только выполненную команду
         if (!executed) {
             System.err.println("PanCommand: Попытка отмены невыполненной команды.");
             return false;
         }

         FractalState currentState = viewModel.getCurrentState();
         Viewport currentViewport = currentState.getViewport();

         // Вычисляем предыдущий viewport, применяя обратный сдвиг к ТЕКУЩЕМУ viewport
         Viewport previousViewport = currentViewport.pan(-deltaX, -deltaY);

         // Создаем восстановленное состояние
         FractalState restoredState = currentState.withViewport(previousViewport);
         // Обновляем состояние в ViewModel. ViewModel сам позаботится об уведомлениях позже.
         viewModel.updateStateFromCommand(restoredState);
         executed = false; // Сбрасываем флаг, позволяя выполнить команду снова (если потребуется Redo)
                           // Для простого Undo/Execute цикла этого достаточно.
         System.out.println("PanCommand: Отменено. Восстановленный viewport: " + previousViewport);
         return true;
    }
}

// File: core/src/main/java/viewmodel/commands/Command.java

// File: core/src/main/java/viewmodel/commands/Command.java
package viewmodel.commands;

/**
 * Интерфейс, представляющий собой команду в рамках паттерна "Команда".
 * Команды инкапсулируют запросы на выполнение действий, обычно связанных
 * с изменением состояния приложения (в данном случае, состояния фрактала
 * {@link model.FractalState}, управляемого {@link viewmodel.FractalViewModel}).
 * <p>
 * Ключевой особенностью является поддержка отмены действия через метод {@link #undo()}.
 * Это позволяет реализовать функциональность Undo/Redo с помощью менеджера команд,
 * такого как {@link UndoManager}.
 * </p>
 */
public interface Command {
    /**
     * Выполняет инкапсулированное действие команды.
     * Как правило, это приводит к изменению состояния в {@link viewmodel.FractalViewModel}.
     * Реализация должна быть идемпотентной в том смысле, что повторный вызов
     * без предварительного вызова {@link #undo()} не должен приводить к
     * повторному эффекту (обычно реализуется через внутренний флаг).
     *
     * @return {@code true}, если команда была успешно выполнена и состояние (потенциально)
     *         изменилось; {@code false}, если выполнение не удалось или было пропущено
     *         (например, команда уже была выполнена, или условия для выполнения не соблюдены).
     */
    boolean execute();

    /**
     * Отменяет действие, ранее выполненное методом {@link #execute()}.
     * Восстанавливает состояние приложения к тому виду, который был до выполнения команды.
     * Реализация также должна быть идемпотентной: повторный вызов {@code undo()}
     * без промежуточного {@code execute()} не должен иметь эффекта.
     *
     * @return {@code true}, если отмена прошла успешно и состояние было восстановлено;
     *         {@code false}, если отмена невозможна (например, команда не была выполнена
     *         или уже была отменена).
     */
    boolean undo();
}

// File: core/src/main/java/viewmodel/commands/UndoManager.java

// File: core/src/main/java/viewmodel/commands/UndoManager.java
package viewmodel.commands;

import java.util.ArrayDeque;
import java.util.Deque;
import java.util.Objects;

/**
 * Менеджер истории команд, реализующий функциональность отмены (Undo).
 * Использует паттерн Команда ({@link Command}).
 * <p>
 * Хранит последовательность выполненных команд в стеке (LIFO - Last-In, First-Out).
 * Позволяет добавлять команды в историю, проверять возможность отмены,
 * выполнять отмену последней команды и очищать историю.
 * </p><p>
 * Имеет ограничение на максимальное количество команд в истории
 * ({@code maxHistorySize}). При добавлении новой команды сверх лимита,
 * самая старая команда автоматически удаляется.
 * </p><p>
 * В качестве стека используется {@link ArrayDeque}, как эффективная реализация {@link Deque}.
 * </p>
 */
public class UndoManager {
    /**
     * Стек для хранения истории выполненных команд.
     * Последняя выполненная команда находится на вершине стека (добавляется через {@code push}).
     * Операция отмены (Undo) извлекает команду с вершины (через {@code pop}).
     */
    private final Deque<Command> history;
    /**
     * Максимальный размер истории команд. Определяет, сколько шагов отмены доступно.
     */
    private final int maxHistorySize;

    /**
     * Создает {@code UndoManager} с заданным максимальным размером истории отмены.
     *
     * @param maxHistorySize Максимальное количество команд, которое будет храниться в истории.
     *                       Должно быть положительным числом (> 0).
     * @throws IllegalArgumentException если {@code maxHistorySize} не является положительным.
     */
    public UndoManager(int maxHistorySize) {
        if (maxHistorySize <= 0) {
            throw new IllegalArgumentException("Максимальный размер истории должен быть положительным.");
        }
        this.maxHistorySize = maxHistorySize;
        // Используем ArrayDeque как эффективную реализацию стека/очереди
        this.history = new ArrayDeque<>(maxHistorySize); // Начальная емкость для оптимизации
    }

    /**
     * Добавляет выполненную команду в историю (на вершину стека).
     * <p>
     * Если текущий размер истории равен или превышает {@link #maxHistorySize},
     * самая старая команда (находящаяся в "хвосте" {@link Deque} при использовании как стека)
     * удаляется перед добавлением новой команды {@code command}.
     * </p>
     *
     * @param command Команда, которая была успешно выполнена и должна быть добавлена
     *                в историю для возможной отмены. Не должна быть null.
     * @throws NullPointerException если {@code command} равна null.
     */
    public void addCommand(Command command) {
        Objects.requireNonNull(command, "Команда для добавления в UndoManager не может быть null");
        // Проверяем, не достигнут ли лимит истории
        if (history.size() >= maxHistorySize) {
            history.removeLast(); // Удаляем самый старый элемент (из "дна" стека/конца Deque)
        }
        history.push(command); // Добавляем новый элемент на "вершину" стека (в начало Deque)
    }

    /**
     * Проверяет, возможна ли в данный момент операция отмены (Undo).
     * Отмена возможна, если история команд не пуста.
     *
     * @return {@code true}, если в истории есть хотя бы одна команда для отмены
     *         ({@code history.size() > 0}), {@code false} в противном случае.
     */
    public boolean canUndo() {
        return !history.isEmpty();
    }

    /**
     * Отменяет последнюю выполненную команду.
     * <p>
     * Если история не пуста ({@code canUndo() == true}):
     * <ol>
     *     <li>Извлекает последнюю команду с вершины стека ({@code history.pop()}).</li>
     *     <li>Вызывает метод {@link Command#undo()} для извлеченной команды.</li>
     * </ol>
     * </p>
     *
     * @return {@code true}, если команда была успешно извлечена и ее метод {@code undo()}
     *         был вызван (возвращаемое значение {@code command.undo()} игнорируется здесь,
     *         предполагается, что оно обработано внутри команды или ViewModel);
     *         {@code false}, если история была пуста и отменять было нечего.
     */
    public boolean undo() {
        if (!canUndo()) {
            System.out.println("UndoManager: Нет действий для отмены.");
            return false; // Нечего отменять
        }
        Command lastCommand = history.pop(); // Снимаем команду с вершины стека
        System.out.println("UndoManager: Отмена команды " + lastCommand.getClass().getSimpleName());
        // Выполняем отмену действия этой команды.
        // Возвращаемое значение lastCommand.undo() здесь не используется,
        // т.к. ViewModel должен обработать изменение состояния независимо.
        boolean undoSuccess = lastCommand.undo();
        if (!undoSuccess) {
             // Логируем, если сама команда сообщила о неудаче отмены
             System.err.println("UndoManager: Команда " + lastCommand.getClass().getSimpleName() + " сообщила о неудаче операции undo().");
             // Возможно, стоит вернуть команду обратно в стек? Зависит от логики. Пока просто логируем.
        }
        return true; // Возвращаем true, так как команда была извлечена и undo вызван.
    }

    /**
     * Полностью очищает историю команд.
     * После вызова этого метода операция Undo ({@link #undo()}) будет невозможна
     * до добавления новых команд. Используется, например, при загрузке нового состояния.
     */
    public void clearHistory() {
        System.out.println("UndoManager: История очищена.");
        history.clear();
    }

    /**
     * Возвращает текущее количество команд, хранящихся в истории отмены.
     * Может быть полезно для отладки или отображения информации пользователю.
     *
     * @return Количество команд в истории (от 0 до {@link #maxHistorySize}).
     */
    public int getHistorySize() {
        return history.size();
    }
}

// File: core/src/main/java/viewmodel/commands/ZoomCommand.java

// File: core/src/main/java/viewmodel/commands/ZoomCommand.java
package viewmodel.commands;

import model.FractalState;
import model.Viewport;
import viewmodel.FractalViewModel; // Добавлен импорт для доступа к ViewModel

import java.util.Objects;

/**
 * Реализация интерфейса {@link Command}, отвечающая за операцию
 * масштабирования (зума) области просмотра фрактала ({@link Viewport}).
 * <p>
 * При выполнении ({@link #execute()}) команда:
 * <ol>
 *     <li>Вычисляет новый {@code Viewport}, соответствующий запрошенной области
 *         (с коррекцией соотношения сторон).</li>
 *     <li>Динамически рассчитывает новое максимальное количество итераций
 *         на основе степени приближения (чем ближе зум, тем больше итераций).</li>
 *     <li>Обновляет состояние в {@link FractalViewModel}, устанавливая новый
 *         {@code Viewport} и новое количество итераций.</li>
 *     <li>Сохраняет предыдущий {@code Viewport} и предыдущее количество итераций для возможности отмены.</li>
 * </ol>
 * При отмене ({@link #undo()}) команда восстанавливает предыдущий {@code Viewport}
 * и предыдущее количество итераций в {@link FractalViewModel}.
 * </p>
 */
public class ZoomCommand implements Command {

    /** Ссылка на ViewModel для доступа к текущему состоянию и его обновления. */
    private final FractalViewModel viewModel;
    /** Минимальная вещественная координата целевой области зума. */
    private final double targetMinX;
    /** Максимальная вещественная координата целевой области зума. */
    private final double targetMaxX;
    /** Минимальная мнимая координата целевой области зума. */
    private final double targetMinY;
    /** Максимальная мнимая координата целевой области зума. */
    private final double targetMaxY;
    /** Целевое соотношение сторон (ширина/высота) для нового Viewport. */
    private final double targetAspectRatio;

    // Поля для сохранения состояния перед выполнением команды (для undo)
    /** Viewport, который был активен до выполнения этой команды. */
    private Viewport previousViewport;
    /** Количество итераций, которое было активно до выполнения этой команды. */
    private int previousMaxIterations;
    /** Флаг, указывающий, была ли команда уже выполнена хотя бы один раз. */
    private boolean executed = false;

    // Параметры для расчета динамических итераций
    /** Базовое количество итераций, к которому добавляется дельта при зуме. */
    private final int baseIterations;
    /** Коэффициент, влияющий на скорость роста итераций при зуме. */
    private final double iterationZoomSensitivity;


    /**
     * Создает команду масштабирования (зума).
     *
     * @param viewModel         ViewModel, состояние которой будет изменяться. Не может быть null.
     * @param x1                Одна из вещественных координат целевой области масштабирования.
     * @param x2                Другая вещественная координата целевой области масштабирования.
     * @param y1                Одна из мнимых координат целевой области масштабирования.
     * @param y2                Другая мнимая координата целевой области масштабирования.
     * @param targetAspectRatio Желаемое соотношение сторон нового Viewport (обычно соответствует панели). Должно быть > 0.
     * @param baseIterations    Базовое/минимальное количество итераций для расчета при зуме. Должно быть > 0.
     * @param iterationZoomSensitivity Коэффициент чувствительности роста итераций (больше значение - быстрее растут).
     * @throws NullPointerException если {@code viewModel} равен null.
     * @throws IllegalArgumentException если {@code targetAspectRatio <= 0} или {@code baseIterations <= 0}.
     */
    public ZoomCommand(FractalViewModel viewModel,
                       double x1, double x2, double y1, double y2,
                       double targetAspectRatio,
                       int baseIterations, double iterationZoomSensitivity) {
        this.viewModel = Objects.requireNonNull(viewModel, "ViewModel не может быть null");
        // Упорядочиваем координаты сразу
        this.targetMinX = Math.min(x1, x2);
        this.targetMaxX = Math.max(x1, x2);
        this.targetMinY = Math.min(y1, y2);
        this.targetMaxY = Math.max(y1, y2);

        if (targetAspectRatio <= 0) {
            throw new IllegalArgumentException("Целевое соотношение сторон должно быть положительным.");
        }
        this.targetAspectRatio = targetAspectRatio;

         if (baseIterations <= 0) {
            throw new IllegalArgumentException("Базовое количество итераций должно быть положительным.");
        }
        this.baseIterations = baseIterations;
        this.iterationZoomSensitivity = iterationZoomSensitivity;

        // Инициализируем поля для undo
        this.previousViewport = null;
        this.previousMaxIterations = 0;
    }

    /**
     * Выполняет команду масштабирования (зума).
     * <p>
     * Сохраняет текущий {@code Viewport} и {@code maxIterations} для отмены.
     * Вычисляет новый {@code Viewport} с помощью {@link Viewport#zoom(double, double, double, double, double)}.
     * Вычисляет новое количество итераций с помощью {@link #calculateNewIterations(Viewport, Viewport, int)}.
     * Создает новый {@link FractalState} с этими значениями и обновляет состояние в {@link #viewModel}.
     * </p>
     * @return {@code true}, если команда была успешно выполнена (еще не выполнялась или была отменена,
     *         и новый Viewport отличается от предыдущего), {@code false} в противном случае.
     */
    @Override
    public boolean execute() {
        if (executed) {
            System.err.println("ZoomCommand: Попытка повторного выполнения команды без предварительной отмены.");
            return false;
        }

        FractalState currentState = viewModel.getCurrentState();
        // Сохраняем состояние *перед* выполнением для возможности отмены
        this.previousViewport = currentState.getViewport();
        this.previousMaxIterations = currentState.getMaxIterations();

        // 1. Вычисляем новый viewport с коррекцией аспекта
        Viewport newViewport = previousViewport.zoom(targetMinX, targetMaxX, targetMinY, targetMaxY, targetAspectRatio);

        // Проверяем, изменился ли viewport после зума (может не измениться при ошибках или малом выделении)
        if (Objects.equals(newViewport, previousViewport)) {
            System.out.println("ZoomCommand: Viewport не изменился после зума. Выполнение пропущено.");
            // Сбрасываем сохраненное состояние, так как команда не была реально выполнена
            this.previousViewport = null;
            this.previousMaxIterations = 0;
            return false; // Изменений нет
        }

        // 2. Вычисляем новое количество итераций на основе изменения масштаба
        int newMaxIterations = calculateNewIterations(previousViewport, newViewport, this.previousMaxIterations);

        // 3. Создаем новое состояние с новым viewport И новыми итерациями
        FractalState nextState = currentState
            .withViewport(newViewport)
            .withMaxIterations(newMaxIterations); // Устанавливаем рассчитанные итерации

        // 4. Обновляем состояние в ViewModel
        viewModel.updateStateFromCommand(nextState);
        executed = true; // Помечаем команду как выполненную
        System.out.printf("ZoomCommand: Выполнено. Viewport: %s, Iterations: %d%n", newViewport, newMaxIterations);
        return true;
    }


    /**
     * Отменяет действие команды масштабирования.
     * <p>
     * Восстанавливает {@code Viewport} и {@code maxIterations}, которые были сохранены
     * при последнем вызове {@link #execute()}, и обновляет состояние в {@link #viewModel}.
     * </p>
     * @return {@code true}, если отмена прошла успешно (команда была ранее выполнена),
     *         {@code false} в противном случае.
     */
    @Override
    public boolean undo() {
        if (!executed) {
            System.err.println("ZoomCommand: Попытка отмены невыполненной команды.");
            return false;
        }
        // Проверяем, было ли сохранено предыдущее состояние (дополнительная защита)
        if (previousViewport == null) {
             System.err.println("ZoomCommand: Ошибка отмены - предыдущее состояние не было сохранено.");
             executed = false; // Сбрасываем флаг в любом случае
             return false;
        }

        FractalState currentState = viewModel.getCurrentState();

        // Создаем восстановленное состояние с предыдущим viewport И предыдущими итерациями
        FractalState restoredState = currentState
            .withViewport(previousViewport)
            .withMaxIterations(previousMaxIterations); // Восстанавливаем предыдущие итерации

        // Обновляем состояние в ViewModel
        viewModel.updateStateFromCommand(restoredState);

        // Сбрасываем сохраненное состояние и флаг
        this.previousViewport = null; // Очищаем, чтобы избежать утечек и повторной отмены
        this.previousMaxIterations = 0;
        executed = false;
        System.out.printf("ZoomCommand: Отменено. Viewport: %s, Iterations: %d%n",
            restoredState.getViewport(), restoredState.getMaxIterations());
        return true;
    }

    /**
     * Рассчитывает новое рекомендуемое количество итераций на основе изменения масштаба (зума).
     * Идея в том, чтобы увеличивать детализацию (количество итераций) при приближении
     * для лучшего рассмотрения сложных структур фрактала.
     * Использует логарифмическую зависимость от коэффициента масштабирования.
     *
     * @param oldViewport      Viewport *до* выполнения зума.
     * @param newViewport      Viewport *после* выполнения зума.
     * @param currentIterations Текущее количество итераций (до расчета новых). Не используется напрямую в формуле,
     *                         но может использоваться для альтернативных расчетов (например, относительное увеличение).
     *                         Текущая формула использует {@link #baseIterations}.
     * @return Рассчитанное новое количество итераций, но не менее {@link #baseIterations}.
     */
    private int calculateNewIterations(Viewport oldViewport, Viewport newViewport, int currentIterations) {
         // Используем ширину для определения масштаба. Можно использовать и высоту или площадь.
         double oldWidth = oldViewport.getWidth();
         double newWidth = newViewport.getWidth();

         // Избегаем деления на ноль или некорректных значений
         final double EPSILON = 1e-9;
         if (oldWidth < EPSILON || newWidth < EPSILON) {
             System.err.println("Предупреждение: Расчет новых итераций пропущен из-за нулевой ширины Viewport.");
             return Math.max(this.baseIterations, currentIterations); // Возвращаем большее из базового и текущего
         }

         // Коэффициент масштабирования (во сколько раз уменьшилась ширина/увеличился зум)
         double zoomLevelFactor = oldWidth / newWidth;

         // Если произошло отдаление (zoomLevelFactor < 1), итерации не уменьшаем ниже базовых.
         // Логарифм от числа < 1 отрицателен.
         if (zoomLevelFactor <= 0) { // Логарифм не определен для <= 0
              System.err.println("Предупреждение: Некорректный zoomLevelFactor <= 0 для расчета итераций.");
              return Math.max(this.baseIterations, currentIterations);
         }

         // Формула: Новые Итерации = БазовыеИтерации + log(КоэффициентЗума) * Чувствительность
         // Math.log() - натуральный логарифм.
         // Добавляем прирост к БАЗОВЫМ итерациям.
         int calculatedIterations = this.baseIterations + (int) (Math.log(zoomLevelFactor) * this.iterationZoomSensitivity);

         // Ограничиваем минимальным значением (baseIterations) и, возможно, максимальным (если нужно)
         return Math.max(this.baseIterations, calculatedIterations);

         // Альтернативная формула: относительное увеличение от текущих итераций
         /*
         int deltaIterations = (int) (Math.log(zoomLevelFactor) * this.iterationZoomSensitivity);
         int calculatedIterations = currentIterations + deltaIterations; // Добавляем к текущим
         return Math.max(this.baseIterations, calculatedIterations); // Ограничиваем базовыми снизу
         */
    }
}

// File: core/src/main/java/services/FileService.java

// File: core/src/main/java/services/FileService.java
package services;

import model.FractalState;
import model.Viewport;

import javax.imageio.ImageIO;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.*;
import java.util.Objects;

/**
 * Сервисный класс (Фасад), предоставляющий операции для работы с файлами,
 * связанные с приложением визуализации фракталов.
 * <p>
 * Отвечает за:
 * <ul>
 *     <li>Сохранение состояния фрактала ({@link FractalState}) в бинарный файл формата {@code .frac}
 *         с использованием сериализации Java.</li>
 *     <li>Загрузку состояния фрактала из файла {@code .frac}.</li>
 *     <li>Экспорт текущего вида фрактала в виде изображений формата JPEG или PNG,
 *         с добавлением текстовой подписи с параметрами вида (координаты, итерации).</li>
 * </ul>
 * </p>
 */
public class FileService {

    /** Расширение файла для сохранения состояния фрактала. */
    private static final String FRAC_EXTENSION = ".frac";
    /** Расширение файла для сохранения JPEG изображений. */
    private static final String JPG_EXTENSION = ".jpg";
    /** Расширение файла для сохранения PNG изображений. */
    private static final String PNG_EXTENSION = ".png";


    /**
     * Сохраняет переданное состояние фрактала {@link FractalState} в указанный файл
     * с использованием механизма сериализации Java.
     * Файлу автоматически добавляется расширение {@value #FRAC_EXTENSION}, если оно отсутствует.
     *
     * @param state    Состояние {@link FractalState} для сохранения. Не может быть null.
     * @param file     Файл назначения. Не может быть null. Путь к файлу должен существовать.
     *                 Если имя файла не содержит {@value #FRAC_EXTENSION}, оно будет добавлено.
     * @throws IOException Если возникает ошибка ввода/вывода во время записи файла (например, нет прав доступа).
     * @throws NullPointerException если {@code state} или {@code file} равны null.
     */
    public void saveFractalState(FractalState state, File file) throws IOException {
        Objects.requireNonNull(state, "Состояние FractalState не может быть null для сохранения");
        Objects.requireNonNull(file, "Файл для сохранения состояния не может быть null");

        // Убедимся, что файл имеет правильное расширение
        File targetFile = ensureExtension(file, FRAC_EXTENSION);

        // Используем try-with-resources для автоматического закрытия потоков
        try (ObjectOutputStream oos = new ObjectOutputStream(
                                           new BufferedOutputStream(
                                               new FileOutputStream(targetFile)))) {
            oos.writeObject(state); // Сериализуем объект состояния
            System.out.println("Состояние фрактала успешно сохранено в: " + targetFile.getAbsolutePath());
        } catch (IOException e) {
            System.err.println("Ошибка при сохранении состояния фрактала в " + targetFile.getAbsolutePath() + ": " + e.getMessage());
            throw e; // Перебрасываем исключение дальше
        }
    }

    /**
     * Загружает состояние фрактала {@link FractalState} из указанного файла формата {@code .frac}.
     * Выполняет десериализацию объекта из файла.
     *
     * @param file Файл формата {@code .frac} для загрузки. Не может быть null, должен существовать
     *             и иметь расширение {@value #FRAC_EXTENSION}.
     * @return Загруженный объект {@link FractalState}.
     * @throws IOException            Если возникает ошибка ввода/вывода во время чтения файла.
     * @throws FileNotFoundException  Если файл не найден или не является обычным файлом.
     * @throws ClassNotFoundException Если класс {@code FractalState} (или один из его зависимых классов)
     *                                не найден во время десериализации (проблема classpath или версии).
     * @throws ClassCastException     Если объект, десериализованный из файла, не является
     *                                экземпляром {@code FractalState}.
     * @throws IllegalArgumentException Если файл не имеет расширения {@value #FRAC_EXTENSION}.
     * @throws NullPointerException   если {@code file} равен null.
     */
    public FractalState loadFractalState(File file) throws IOException, ClassNotFoundException {
        Objects.requireNonNull(file, "Файл для загрузки состояния не может быть null");

        if (!file.exists() || !file.isFile()) {
            throw new FileNotFoundException("Файл не найден или не является обычным файлом: " + file.getAbsolutePath());
        }
         // Проверяем расширение файла
         if (!file.getName().toLowerCase().endsWith(FRAC_EXTENSION)) {
             throw new IllegalArgumentException("Файл для загрузки состояния должен иметь расширение " + FRAC_EXTENSION);
         }

        // Используем try-with-resources для автоматического закрытия потоков
        try (ObjectInputStream ois = new ObjectInputStream(
                                           new BufferedInputStream(
                                               new FileInputStream(file)))) {
            Object loadedObject = ois.readObject(); // Десериализуем объект
            if (loadedObject instanceof FractalState) {
                System.out.println("Состояние фрактала успешно загружено из: " + file.getAbsolutePath());
                return (FractalState) loadedObject;
            } else {
                // Если файл содержит объект другого типа
                throw new ClassCastException("Файл не содержит корректный объект FractalState. Обнаружен тип: "
                                             + (loadedObject != null ? loadedObject.getClass().getName() : "null"));
            }
        } catch (IOException | ClassNotFoundException | ClassCastException e) {
            System.err.println("Ошибка при загрузке состояния фрактала из " + file.getAbsolutePath() + ": " + e.getMessage());
            throw e; // Перебрасываем исключение дальше
        }
    }

     /**
     * Сохраняет переданное изображение {@link BufferedImage} в файл указанного формата (JPEG или PNG).
     * Перед сохранением на изображение добавляется текстовая подпись (caption), содержащая
     * информацию о текущем виде фрактала (координаты {@link Viewport} и максимальное
     * количество итераций) из объекта {@code state}.
     * Файлу автоматически присваивается соответствующее расширение ({@value #JPG_EXTENSION} или {@value #PNG_EXTENSION}),
     * если оно отсутствует или некорректно.
     *
     * @param image     Изображение {@link BufferedImage} для сохранения. Не может быть null.
     * @param state     Текущее состояние {@link FractalState}, используемое для получения
     *                  информации (координаты, итерации) для подписи на изображении. Не может быть null.
     * @param file      Файл назначения. Не может быть null. Путь к файлу должен существовать.
     *                  Расширение будет скорректировано автоматически.
     * @param format    Строка, определяющая желаемый формат сохранения: "JPEG" (или "JPG") или "PNG"
     *                  (регистр не важен). Не может быть null.
     * @throws IOException              Если возникает ошибка ввода/вывода во время записи файла
     *                                  или если не найден подходящий {@code ImageWriter} для формата.
     * @throws IllegalArgumentException Если указан неподдерживаемый {@code format}.
     * @throws NullPointerException     если {@code image}, {@code state}, {@code file} или {@code format} равны null.
     */
     public void saveImage(BufferedImage image, FractalState state, File file, String format) throws IOException {
         Objects.requireNonNull(image, "Изображение (image) не может быть null для сохранения");
         Objects.requireNonNull(state, "Состояние (state) не может быть null для добавления подписи");
         Objects.requireNonNull(file, "Файл для сохранения изображения не может быть null");
         Objects.requireNonNull(format, "Формат изображения (format) не может быть null");

         String lowerFormat = format.toLowerCase().trim();
         String targetFormat; // Финальный формат для ImageIO ("jpeg" или "png")
         String targetExtension; // Ожидаемое расширение файла (".jpg" или ".png")

         if ("jpeg".equals(lowerFormat) || "jpg".equals(lowerFormat)) {
              targetFormat = "jpeg";
              targetExtension = JPG_EXTENSION;
         } else if ("png".equals(lowerFormat)) {
              targetFormat = "png";
              targetExtension = PNG_EXTENSION;
         } else {
             // Если формат не JPEG и не PNG
             throw new IllegalArgumentException("Неподдерживаемый формат изображения: " + format + ". Используйте JPEG или PNG.");
         }

         // Убедимся, что файл имеет правильное расширение
         File targetFile = ensureExtension(file, targetExtension);

         // Создаем новое изображение для рисования подписи, чтобы не изменять оригинал
         // Для JPEG используем TYPE_INT_RGB (без альфа-канала), для PNG - TYPE_INT_ARGB (с альфа-каналом)
         int imageType = targetFormat.equals("jpeg") ? BufferedImage.TYPE_INT_RGB : BufferedImage.TYPE_INT_ARGB;
         BufferedImage imageWithCaption = new BufferedImage(image.getWidth(), image.getHeight(), imageType);

         // Получаем Graphics2D для рисования на новом изображении
         Graphics2D g = imageWithCaption.createGraphics();
         try {
             // 1. Рисуем исходное изображение на новом холсте
             g.drawImage(image, 0, 0, null);

             // 2. Добавляем текстовую подпись с параметрами вида
             Viewport vp = state.getViewport();
             // Используем %g для компактного вывода double, %.6g для большей точности при необходимости
             String caption = String.format("Viewport: X=[%.6g, %.6g], Y=[%.6g, %.6g], Iter: %d",
                                            vp.getMinX(), vp.getMaxX(), vp.getMinY(), vp.getMaxY(), state.getMaxIterations());

             // Настройки для рендеринга текста (шрифт, сглаживание)
             g.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
             g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
             g.setFont(new Font("SansSerif", Font.BOLD, 14)); // Можно сделать настраиваемым

             // Выбираем позицию и цвет для текста
             FontMetrics fm = g.getFontMetrics();
             int textHeight = fm.getAscent(); // Высота текста над базовой линией
             int padding = 5; // Отступ от краев
             int textY = image.getHeight() - padding; // Позиция Y базовой линии текста (внизу)
             int textX = padding;                   // Позиция X текста (слева)

             // Рисуем текст с контрастной обводкой для лучшей читаемости на любом фоне
             Color textColor = Color.WHITE;
             Color outlineColor = Color.BLACK;
             int outlineOffset = 1; // Смещение обводки

             // Рисуем обводку (текст со смещением в 8 направлениях)
             g.setColor(outlineColor);
             g.drawString(caption, textX - outlineOffset, textY - outlineOffset);
             g.drawString(caption, textX + outlineOffset, textY - outlineOffset);
             g.drawString(caption, textX - outlineOffset, textY + outlineOffset);
             g.drawString(caption, textX + outlineOffset, textY + outlineOffset);
             g.drawString(caption, textX, textY - outlineOffset);
             g.drawString(caption, textX, textY + outlineOffset);
             g.drawString(caption, textX - outlineOffset, textY);
             g.drawString(caption, textX + outlineOffset, textY);

             // Рисуем основной текст поверх обводки
             g.setColor(textColor);
             g.drawString(caption, textX, textY);

         } finally {
             g.dispose(); // Освобождаем ресурсы Graphics2D - ВАЖНО!
         }

         // 3. Сохраняем изображение с подписью в выбранном формате
         boolean success = ImageIO.write(imageWithCaption, targetFormat, targetFile);

         if (!success) {
             // ImageIO.write возвращает false, если не найден подходящий ImageWriter
             throw new IOException("Не удалось сохранить изображение: не найден подходящий writer для формата '" + targetFormat + "'.");
         }
         System.out.println("Изображение успешно сохранено в: " + targetFile.getAbsolutePath() + " (формат: " + targetFormat.toUpperCase() + ")");
     }

    /**
     * Вспомогательный метод для проверки и добавления/замены расширения файла.
     * @param originalFile Исходный файл.
     * @param desiredExtension Ожидаемое расширение (включая точку, например, ".txt").
     * @return Новый объект File с гарантированно правильным расширением.
     */
    private File ensureExtension(File originalFile, String desiredExtension) {
        String fileName = originalFile.getName();
        String lowerCaseFileName = fileName.toLowerCase();
        String lowerCaseDesiredExtension = desiredExtension.toLowerCase();

        // Если расширение уже правильное, возвращаем исходный файл
        if (lowerCaseFileName.endsWith(lowerCaseDesiredExtension)) {
            return originalFile;
        }

        // Иначе, формируем новое имя
        String nameWithoutExt;
        int lastDotIndex = fileName.lastIndexOf('.');
        // Если точки нет или она в самом начале (скрытый файл)
        if (lastDotIndex <= 0) {
            nameWithoutExt = fileName;
        } else {
            // Отбрасываем текущее расширение
            nameWithoutExt = fileName.substring(0, lastDotIndex);
        }
        // Создаем новое имя с нужным расширением
        String newFileName = nameWithoutExt + desiredExtension;
        // Возвращаем новый объект File с тем же путем, но новым именем
        return new File(originalFile.getParentFile(), newFileName);
    }
}

// File: core/src/main/java/services/AnimationService.java

// File: core/src/main/java/services/AnimationService.java
package services;

import model.ColorScheme;
import model.FractalState;
import model.Keyframe;
import model.Viewport;
import math.FractalFunction; // Добавлен правильный импорт
import org.jcodec.api.awt.AWTSequenceEncoder;
// import org.jcodec.common.io.NIOUtils; // Используется ниже
import org.jcodec.common.io.SeekableByteChannel; // <-- Добавлен импорт
import org.jcodec.common.model.Rational;
import utils.ComplexNumber;
import utils.CoordinateConverter;


import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.function.Consumer;

/**
 * Сервис для создания и сохранения анимированной "экскурсии по фракталу".
 * Генерирует последовательность кадров путем интерполяции между заданными
 * ключевыми кадрами {@link Keyframe} и кодирует их в видеофайл формата MP4
 * с использованием библиотеки JCodec.
 */
public class AnimationService {

    // Размер рендерируемых кадров для анимации (можно сделать настраиваемым)
    private static final int FRAME_WIDTH = 800;
    private static final int FRAME_HEIGHT = 600;
    // Размер тайла для рендеринга кадров (влияет на отзывчивость прогресса)
    private static final int RENDER_TILE_SIZE = 64;


    public AnimationService() {
        System.out.println("AnimationService initialized.");
    }

    /**
     * Создает и сохраняет анимацию фрактала в видеофайл MP4.
     * Выполняет интерполяцию между ключевыми кадрами, рендерит каждый промежуточный кадр
     * и кодирует последовательность кадров в видео. Операция выполняется синхронно
     * в вызывающем потоке (предполагается, что это фоновый поток, например, SwingWorker).
     *
     * @param keyframes Список ключевых кадров {@link Keyframe}. Должен содержать минимум 2 кадра.
     * @param fps Частота кадров в секунду (Frames Per Second) для итогового видео.
     * @param durationPerSegment Продолжительность анимационного сегмента *между* двумя
     *                           последовательными ключевыми кадрами (в секундах).
     * @param outputFile Файл для сохранения видео (должен иметь расширение .mp4).
     * @param progressConsumer Callback для уведомления о прогрессе генерации (принимает значение от 0.0 до 1.0).
     * @param statusConsumer Callback для отправки текстовых сообщений о статусе.
     * @throws IOException Если возникает ошибка при рендеринге или записи видеофайла.
     * @throws IllegalArgumentException Если список keyframes содержит менее 2 кадров, или параметры некорректны.
     * @throws InterruptedException Если поток выполнения был прерван во время рендеринга.
     */
    public void createAndSaveAnimation(List<Keyframe> keyframes,
                                       int fps,
                                       double durationPerSegment,
                                       File outputFile,
                                       Consumer<Double> progressConsumer,
                                       Consumer<String> statusConsumer)
            throws IOException, IllegalArgumentException, InterruptedException {

        // --- Валидация входных данных ---
        if (keyframes == null || keyframes.size() < 2) {
            throw new IllegalArgumentException("Для анимации требуется как минимум 2 ключевых кадра.");
        }
        if (fps <= 0) {
            throw new IllegalArgumentException("Частота кадров (FPS) должна быть положительной.");
        }
        if (durationPerSegment <= 0) {
            throw new IllegalArgumentException("Длительность сегмента должна быть положительной.");
        }
        Objects.requireNonNull(outputFile, "Выходной файл не может быть null.");
        Objects.requireNonNull(progressConsumer, "Callback прогресса не может быть null.");
        Objects.requireNonNull(statusConsumer, "Callback статуса не может быть null.");

        statusConsumer.accept("Инициализация кодера видео...");
        AWTSequenceEncoder encoder = null; // Объявляем до try-блока для использования в catch/finally
        SeekableByteChannel channel = null; // Объявляем канал

        try {
            // --- Подготовка к кодированию ---
            // Создаем канал для записи в файл
            channel = org.jcodec.common.io.NIOUtils.writableChannel(outputFile); // Используем полное имя или импортируем NIOUtils
            // Создаем кодер JCodec, передавая канал и FPS
            Rational rationalFps = Rational.R(fps, 1); // fps/1
            encoder = new AWTSequenceEncoder(channel, rationalFps);

            int totalSegments = keyframes.size() - 1;
            int framesPerSegment = Math.max(1, (int) Math.round(fps * durationPerSegment));
            int totalFrames = totalSegments * framesPerSegment;
            int framesRendered = 0;

            statusConsumer.accept(String.format("Начало генерации %d кадров (%d сегментов по %d кадров)...", totalFrames, totalSegments, framesPerSegment));
            progressConsumer.accept(0.0);

            // --- Цикл по сегментам анимации ---
            for (int i = 0; i < totalSegments; i++) {
                if (Thread.currentThread().isInterrupted()) throw new InterruptedException("Генерация анимации прервана.");

                Keyframe startKeyframe = keyframes.get(i);
                Keyframe endKeyframe = keyframes.get(i + 1);
                statusConsumer.accept(String.format("Генерация сегмента %d/%d (кадры %d-%d)...",
                        i + 1, totalSegments, framesRendered + 1, framesRendered + framesPerSegment));

                List<FractalState> intermediateStates = interpolateStates(
                        startKeyframe.getState(),
                        endKeyframe.getState(),
                        framesPerSegment);

                // --- Рендеринг и кодирование кадров сегмента ---
                for (int j = 0; j < intermediateStates.size(); j++) {
                    if (Thread.currentThread().isInterrupted()) throw new InterruptedException("Генерация анимации прервана.");

                    FractalState frameState = intermediateStates.get(j);
                    int currentFrameNumber = framesRendered + j + 1;
                    statusConsumer.accept(String.format("Рендеринг кадра %d/%d...", currentFrameNumber, totalFrames));

                    BufferedImage frameImage = renderSingleFrame(frameState, FRAME_WIDTH, FRAME_HEIGHT);

                    statusConsumer.accept(String.format("Кодирование кадра %d/%d...", currentFrameNumber, totalFrames));
                    encoder.encodeImage(frameImage); // Используем созданный encoder

                    framesRendered++;
                    progressConsumer.accept((double) framesRendered / totalFrames);
                }
            }

            // --- Завершение кодирования ---
            statusConsumer.accept("Завершение записи видеофайла...");
            encoder.finish(); // Завершаем работу энкодера (записывает заголовки и т.д.)
            encoder = null; // Обнуляем ссылку после успешного завершения
            statusConsumer.accept("Видеофайл успешно сохранен: " + outputFile.getName());
            progressConsumer.accept(1.0);

        } catch (IOException e) {
            statusConsumer.accept("Ошибка ввода/вывода при записи видео: " + e.getMessage());
            // Не нужно удалять файл здесь, пусть это решает вызывающий код или пользователь
            throw e;
        } catch (InterruptedException e) {
            statusConsumer.accept("Генерация анимации прервана.");
            // Не нужно удалять файл здесь
            throw e;
        } finally {
            // Закрываем энкодер и канал в блоке finally для гарантии
            if (encoder != null) {
                try {
                    statusConsumer.accept("Попытка аварийного завершения кодера...");
                    encoder.finish(); // Попытка завершить, если еще не завершено
                } catch (Exception ex) {
                    System.err.println("Ошибка при аварийном завершении энкодера: " + ex.getMessage());
                }
            }
            if (channel != null) {
                try {
                    channel.close(); // Закрываем канал
                } catch (IOException ex) {
                    System.err.println("Ошибка при закрытии канала файла: " + ex.getMessage());
                }
            }
            // Если генерация была прервана или неудачна, файл может остаться неполным.
            // Удаление файла лучше оставить на усмотрение пользователя или вызывающего кода.
        }
    }

    // Методы interpolateStates, renderSingleFrame, renderTile остаются без изменений

    /**
     * Выполняет интерполяцию между двумя состояниями фрактала для создания
     * последовательности промежуточных состояний.
     * Интерполирует центр Viewport линейно, а масштаб (ширину/высоту) логарифмически.
     * Количество итераций интерполируется линейно.
     * Цветовая схема и функция фрактала берутся из начального состояния.
     *
     * @param state1 Начальное состояние.
     * @param state2 Конечное состояние.
     * @param numFrames Количество промежуточных кадров, включая начальный и конечный (должно быть >= 2).
     * @return Список {@link FractalState}, представляющий интерполированные кадры.
     */
    private List<FractalState> interpolateStates(FractalState state1, FractalState state2, int numFrames) {
        if (numFrames < 2) {
            return List.of(state1); // Невозможно интерполировать меньше 2 кадров
        }

        List<FractalState> interpolated = new ArrayList<>(numFrames);
        Viewport vp1 = state1.getViewport();
        Viewport vp2 = state2.getViewport();
        int iter1 = state1.getMaxIterations();
        int iter2 = state2.getMaxIterations();
        ColorScheme colorScheme = state1.getColorScheme(); // Берем из первого кадра
        FractalFunction function = state1.getFractalFunction(); // Берем из первого кадра
        // Используем аспект первого кадра как целевой для всех промежуточных
        double aspectRatio = vp1.getAspectRatio();
        // Обработка случая NaN или 0 для аспекта
        if (Double.isNaN(aspectRatio) || aspectRatio <= 0) {
            // Пытаемся взять аспект второго кадра
            aspectRatio = vp2.getAspectRatio();
            if (Double.isNaN(aspectRatio) || aspectRatio <= 0) {
                // Если и он некорректный, используем 4:3 или 16:9 как запасной вариант
                aspectRatio = (double) FRAME_WIDTH / FRAME_HEIGHT; // Используем аспект кадра по умолчанию
                System.err.println("Предупреждение: Не удалось определить корректное соотношение сторон из ключевых кадров, используется " + aspectRatio);
            }
        }


        // Параметры начального Viewport
        double startCenterX = (vp1.getMinX() + vp1.getMaxX()) / 2.0;
        double startCenterY = (vp1.getMinY() + vp1.getMaxY()) / 2.0;
        double startWidth = vp1.getWidth();
        // Обработка нулевой ширины для логарифма
        double startLogWidth = (startWidth > 1e-9) ? Math.log(startWidth) : -Double.MAX_VALUE;

        // Параметры конечного Viewport
        double endCenterX = (vp2.getMinX() + vp2.getMaxX()) / 2.0;
        double endCenterY = (vp2.getMinY() + vp2.getMaxY()) / 2.0;
        double endWidth = vp2.getWidth();
        // Обработка нулевой ширины для логарифма
        double endLogWidth = (endWidth > 1e-9) ? Math.log(endWidth) : -Double.MAX_VALUE;


        for (int i = 0; i < numFrames; i++) {
            // Фактор интерполяции от 0.0 до 1.0
            double t = (numFrames <= 1) ? 0.0 : (double) i / (numFrames - 1);

            // Линейная интерполяция центра
            double currentCenterX = startCenterX * (1.0 - t) + endCenterX * t;
            double currentCenterY = startCenterY * (1.0 - t) + endCenterY * t;

            // Логарифмическая интерполяция масштаба (ширины)
            double currentLogWidth = startLogWidth * (1.0 - t) + endLogWidth * t;
            double currentWidth = Math.exp(currentLogWidth);
            // Проверка на случай очень маленькой ширины после exp()
            currentWidth = Math.max(1e-9, currentWidth); // Минимальная ширина

            double currentHeight = currentWidth / aspectRatio; // Рассчитываем высоту по аспекту

            // Вычисляем границы нового Viewport
            double currentMinX = currentCenterX - currentWidth / 2.0;
            double currentMaxX = currentCenterX + currentWidth / 2.0;
            double currentMinY = currentCenterY - currentHeight / 2.0;
            double currentMaxY = currentCenterY + currentHeight / 2.0;
            Viewport currentViewport = new Viewport(currentMinX, currentMaxX, currentMinY, currentMaxY);

            // Линейная интерполяция итераций
            int currentIterations = (int) Math.round(iter1 * (1.0 - t) + iter2 * t);
            currentIterations = Math.max(1, currentIterations); // Итераций должно быть > 0

            // Создаем промежуточное состояние
            interpolated.add(new FractalState(currentViewport, currentIterations, colorScheme, function));
        }

        return interpolated;
    }


    /**
     * Синхронно рендерит один кадр (FractalState) в BufferedImage.
     * Эта реализация копирует логику рендеринга тайлов из FractalRenderer,
     * но выполняет ее в текущем (фоновом) потоке без использования внешнего ExecutorService.
     *
     * @param state Состояние фрактала для рендеринга.
     * @param width Ширина изображения кадра.
     * @param height Высота изображения кадра.
     * @return Отрендеренное изображение BufferedImage.
     * @throws InterruptedException если поток был прерван во время рендеринга.
     */
    private BufferedImage renderSingleFrame(FractalState state, int width, int height) throws InterruptedException {
        if (width <= 0 || height <= 0) {
            throw new IllegalArgumentException("Ширина и высота кадра должны быть положительными.");
        }
        // Используем TYPE_INT_RGB, так как большинство видеокодеков плохо работают с альфа-каналом
        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);

        // --- Логика рендеринга ---
        Viewport viewport = state.getViewport();
        int maxIterations = state.getMaxIterations();
        ColorScheme colorScheme = state.getColorScheme();
        FractalFunction fractalFunction = state.getFractalFunction();

        // Проверка на валидность Viewport перед рендерингом
        if (viewport.getWidth() <= 0 || viewport.getHeight() <= 0) {
            System.err.println("Предупреждение: Рендеринг кадра с вырожденным Viewport: " + viewport);
            // Заполняем черным или серым цветом
            Graphics2D g = image.createGraphics();
            g.setColor(Color.DARK_GRAY);
            g.fillRect(0, 0, width, height);
            g.dispose();
            return image;
        }


        List<render.Tile> tiles = render.TileCalculator.calculateTiles(width, height, RENDER_TILE_SIZE);

        for (render.Tile tile : tiles) {
            if (Thread.currentThread().isInterrupted()) {
                throw new InterruptedException("Рендеринг кадра прерван.");
            }
            renderTile(tile, viewport, maxIterations, colorScheme, fractalFunction, width, height, image);
        }

        return image;
    }

    /**
     * Рендерит один тайл изображения фрактала.
     */
    private void renderTile(render.Tile tile, Viewport viewport, int maxIterations,
                            ColorScheme colorScheme, FractalFunction fractalFunction,
                            int imageWidth, int imageHeight, BufferedImage targetImage) throws InterruptedException {

        for (int y = tile.getStartY(); y < tile.getStartY() + tile.getHeight(); ++y) {
            if (Thread.currentThread().isInterrupted()) throw new InterruptedException("Рендеринг тайла прерван.");

            for (int x = tile.getStartX(); x < tile.getStartX() + tile.getWidth(); ++x) {
                ComplexNumber pointCoords = CoordinateConverter.screenToComplex(x, y, imageWidth, imageHeight, viewport);
                if (pointCoords == null) continue;

                int iterations = fractalFunction.calculateIterations(pointCoords, pointCoords, maxIterations);
                Color color = colorScheme.getColor(iterations, maxIterations);

                if (x >= 0 && x < imageWidth && y >= 0 && y < imageHeight) {
                    targetImage.setRGB(x, y, color.getRGB());
                }
            }
        }
    }
}

// File: core/src/main/java/render/TileCalculator.java

package render;

import java.util.ArrayList;
import java.util.List;

/**
 * Utility class to divide an image area into smaller tiles.
 */
public class TileCalculator {

    /**
     * Divides the specified image dimensions into tiles of a given size.
     * The last row/column of tiles might be smaller if dimensions are not divisible.
     *
     * @param imageWidth  Total width of the image.
     * @param imageHeight Total height of the image.
     * @param tileSize    Desired size (width and height) of each tile.
     * @return A list of Tile objects covering the entire image area.
     */
    public static List<Tile> calculateTiles(int imageWidth, int imageHeight, int tileSize) {
        if (imageWidth <= 0 || imageHeight <= 0 || tileSize <= 0) {
            return List.of(); // Возвращаем пустой список для невалидных размеров
        }

        List<Tile> tiles = new ArrayList<>();
        for (int y = 0; y < imageHeight; y += tileSize) {
            for (int x = 0; x < imageWidth; x += tileSize) {
                int currentTileWidth = Math.min(tileSize, imageWidth - x);
                int currentTileHeight = Math.min(tileSize, imageHeight - y);
                tiles.add(new Tile(x, y, currentTileWidth, currentTileHeight));
            }
        }
        return tiles;
    }
}

// File: core/src/main/java/render/Tile.java

package render;

/**
 * Represents a rectangular tile of the image to be rendered.
 */
public class Tile {
    final int startX;
    final int startY;
    final int width;
    final int height;

    /**
     * Constructs a Tile.
     * @param startX Top-left X coordinate (pixel).
     * @param startY Top-left Y coordinate (pixel).
     * @param width Width of the tile (pixels).
     * @param height Height of the tile (pixels).
     */
    public Tile(int startX, int startY, int width, int height) {
        this.startX = startX;
        this.startY = startY;
        this.width = width;
        this.height = height;
    }

    // Геттеры при необходимости
    public int getStartX() { return startX; }
    public int getStartY() { return startY; }
    public int getWidth() { return width; }
    public int getHeight() { return height; }

    @Override
    public String toString() {
        return "Tile{" +
               "startX=" + startX +
               ", startY=" + startY +
               ", width=" + width +
               ", height=" + height +
               '}';
    }
}

// File: core/src/main/java/render/FractalRenderer.java

package render;

import model.ColorScheme;
import model.FractalState;
import model.Viewport;
import utils.ComplexNumber;
import utils.CoordinateConverter;
import math.FractalFunction; // <-- Добавлен импорт


import javax.swing.*;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Consumer;



/**
 * Handles the multi-threaded rendering of the Mandelbrot fractal.
 */
public class FractalRenderer {

    private static final int TILE_SIZE = 32; // Размер тайла в пикселях
    private final ExecutorService executor;
    private final int numThreads;
    private final AtomicReference<RenderTask> currentRenderTask = new AtomicReference<>();

    /**
     * Constructs a new FractalRenderer with a thread pool based on available processors.
     */
    public FractalRenderer() {
        this.numThreads = Runtime.getRuntime().availableProcessors();
        this.executor = Executors.newFixedThreadPool(numThreads);
        System.out.println("Renderer initialized with " + numThreads + " threads.");
    }

    /**
     * Asynchronously renders the fractal based on the given state and dimensions.
     * Cancels any previous render task before starting a new one.
     *
     * @param state      The FractalState defining the view and parameters.
     * @param width      The target image width.
     * @param height     The target image height.
     * @param onComplete Callback to accept the rendered image upon completion (called on EDT).
     * @param onCancel   Callback called if the task is cancelled (called on EDT).
     */
    public void render(FractalState state, int width, int height,
                       Consumer<BufferedImage> onComplete, Runnable onCancel) {
        if (width <= 0 || height <= 0) {
            System.err.println("Invalid render dimensions: " + width + "x" + height);
            SwingUtilities.invokeLater(() -> onComplete.accept(null));
            return;
        }

        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
        RenderTask newTask = new RenderTask(state, width, height, image, onComplete, onCancel);
        RenderTask oldTask = currentRenderTask.getAndSet(newTask);

        if (oldTask != null) {
            oldTask.cancel();
        }

        newTask.startRendering(executor);
    }

    /**
     * Shuts down the thread pool gracefully. Blocks until all tasks are terminated.
     */
    public void shutdown() {
        executor.shutdown();
        try {
            if (!executor.awaitTermination(800, TimeUnit.MILLISECONDS)) {
                executor.shutdownNow();
            }
        } catch (InterruptedException e) {
            executor.shutdownNow();
            Thread.currentThread().interrupt();
        }
        System.out.println("Renderer shut down.");
    }

    private static class RenderTask {
        private final FractalState state;
        private final int width;
        private final int height;
        private final BufferedImage image;
        private final Consumer<BufferedImage> onComplete;
        private final Runnable onCancel;
        private volatile boolean cancelled = false;
        private final List<Future<?>> futures = new ArrayList<>(); // Список задач для отмены

        RenderTask(FractalState state, int width, int height, BufferedImage image,
                   Consumer<BufferedImage> onComplete, Runnable onCancel) {
            this.state = state;
            this.width = width;
            this.height = height;
            this.image = image;
            this.onComplete = onComplete;
            this.onCancel = onCancel;
        }

        /**
         * Cancels the rendering task and interrupts all running tile tasks.
         */
        void cancel() {
            cancelled = true;
            for (Future<?> future : futures) {
                future.cancel(true); // Прерываем потоки
            }
            System.out.println("Render task cancelled.");
            SwingUtilities.invokeLater(onCancel);
        }

        /**
         * Starts the rendering process using the provided ExecutorService.
         *
         * @param executor The thread pool to use for rendering.
         */
        void startRendering(ExecutorService executor) {
            List<Tile> tiles = TileCalculator.calculateTiles(width, height, TILE_SIZE);
            Graphics2D g = image.createGraphics();
            g.setColor(Color.LIGHT_GRAY);
            g.fillRect(0, 0, width, height);
            g.dispose();

            executor.submit(() -> {
                try {
                    long startTime = System.currentTimeMillis();

                    for (Tile tile : tiles) {
                        if (cancelled) break;

                        Future<?> future = executor.submit(() -> {
                            if (!cancelled) {
                                renderTile(tile, state, width, height, image);
                            }
                        });
                        futures.add(future);
                    }

                    for (Future<?> future : futures) {
                        if (cancelled) break;
                        try {
                            future.get();
                        } catch (Exception e) {
                            if (!cancelled) {
                                System.err.println("Error rendering tile: " + e.getMessage());
                            }
                        }
                    }

                    if (!cancelled) {
                        long endTime = System.currentTimeMillis();
                        System.out.printf("Rendering finished in %d ms%n", (endTime - startTime));
                        SwingUtilities.invokeLater(() -> onComplete.accept(image));
                    }

                } catch (Exception e) {
                    System.err.println("Rendering failed: " + e.getMessage());
                    if (!cancelled) {
                        SwingUtilities.invokeLater(() -> onComplete.accept(null));
                    }
                }
            });
        }

        /**
     * Renders a single tile of the fractal image using the FractalFunction from the state.
     *
     * @param tile        The tile to render.
     * @param state       The fractal state containing viewport, iterations, color scheme, and fractal function.
     * @param imageWidth  The total image width.
     * @param imageHeight The total image height.
     * @param targetImage The image to render into.
     */
    private static void renderTile(Tile tile, FractalState state, int imageWidth, int imageHeight, BufferedImage targetImage) {
        Viewport viewport = state.getViewport();
        int maxIterations = state.getMaxIterations();
        ColorScheme colorScheme = state.getColorScheme();
        FractalFunction fractalFunction = state.getFractalFunction(); // <-- Получаем функцию из состояния

        for (int y = tile.startY; y < tile.startY + tile.height; ++y) {
            if (Thread.currentThread().isInterrupted()) return;
            for (int x = tile.startX; x < tile.startX + tile.width; ++x) {
                // Преобразуем пиксельные координаты в комплексное число (это будет и z0 и c для Мандельброта)
                ComplexNumber pointCoords = CoordinateConverter.screenToComplex(x, y, imageWidth, imageHeight, viewport);
                if (pointCoords == null) continue; // Пропускаем, если конвертация не удалась

                // Вычисляем итерации, используя функцию из состояния
                // Для Мандельброта: z0=0 (реализовано в MandelbrotFunction), c=pointCoords
                // Для Жюлиа: z0=pointCoords, c=константа (реализовано в JuliaFunction)
                // Передаем pointCoords как z0 и как c. Конкретная функция решит, что использовать.
                int iterations = fractalFunction.calculateIterations(pointCoords, pointCoords, maxIterations);

                // Получаем цвет на основе итераций
                Color color = colorScheme.getColor(iterations, maxIterations);

                // Устанавливаем пиксель в изображении (с проверкой границ)
                if (x >= 0 && x < targetImage.getWidth() && y >= 0 && y < targetImage.getHeight()) {
                    targetImage.setRGB(x, y, color.getRGB());
                }
            }
        }
    }
        /**
         * Calculates iterations for a point in the Mandelbrot set.
         *
         * @param c             The complex number to test.
         * @param maxIterations The maximum iterations to perform.
         * @return The number of iterations before escaping, or maxIterations if inside.
         */
        private static int calculateMandelbrotIterations(ComplexNumber c, int maxIterations) {
            ComplexNumber z = new ComplexNumber(0, 0);
            for (int i = 0; i < maxIterations; ++i) {
                if (z.magnitudeSquared() > 4.0) return i;
                z = z.square().add(c);
            }
            return maxIterations;
        }
    }
}

